{
  "slots": {
    "0": {
      "name": "slot1",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "1": {
      "name": "slot2",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "2": {
      "name": "slot3",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "3": {
      "name": "slot4",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "4": {
      "name": "slot5",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "5": {
      "name": "slot6",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "6": {
      "name": "slot7",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "7": {
      "name": "slot8",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "8": {
      "name": "slot9",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "9": {
      "name": "slot10",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "10": {
      "name": "slot11",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "11": {
      "name": "slot12",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "12": {
      "name": "slot13",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "13": {
      "name": "slot14",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "14": {
      "name": "slot15",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "15": {
      "name": "slot16",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "16": {
      "name": "slot17",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "17": {
      "name": "slot18",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "18": {
      "name": "slot19",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "19": {
      "name": "slot20",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "20": {
      "name": "slot21",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-3": {
      "name": "library",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-2": {
      "name": "system",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-1": {
      "name": "unit",
      "type": {
        "events": [],
        "methods": []
      }
    }
  },
  "handlers": [
    {
      "code": "--@class SimpleSlotDetectorMin\ncore=nil;antigrav=nil;warpDrive=nil;radarUnit=nil;flightModeDb=nil;manualSwitches={}forceFields={}laser=nil;screen=nil;settingsActive=false;emitter=nil;telemeter=nil;function getElements()for a,b in pairs(_G)do if type(b)==\"table\"and b[\"getClass\"]then local c=b[\"getClass\"]()if c==\"CoreUnitDynamic\"or c==\"CoreUnitStatic\"or c==\"CoreUnitSpace\"then core=b end;if c==\"AtmoFuelContainer\"or c==\"SpaceFuelContainer\"then b.showWidget()end;if c==\"WarpDriveUnit\"then warpDrive=b;b.showWidget()end;if c==\"RadarPvPAtmospheric\"or c==\"RadarPvPSpace\"then radarUnit=b;b.showWidget()end;if c==\"DataBankUnit\"then flightModeDb=b end;if c==\"AntiGravityGeneratorUnit\"then antigrav=b end;if c==\"ManualSwitchUnit\"then table.insert(manualSwitches,b)end;if c==\"ForceFieldUnit\"then table.insert(forceFields,b)end;if c==\"ScreenUnit\"then screen=b end;if c==\"LaserEmitterUnit\"then laser=b end;if c==\"EmitterUnit\"then emitter=b end;if c==\"TelemeterUnit\"then telemeter=b end end end end;getElements()",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "0"
    },
    {
      "code": "--@class ExportedVariables\n\nshipName = \"\"\nupdateSettings = false --export: Use these settings\naltHoldPreset1 = 132000.845  --export: Altitude Hold Preset 1\naltHoldPreset2 = 1005 --export: Altitude Hold Preset 2\naltHoldPreset3 = 50 --export: Altitude Hold Preset 3\naltHoldPreset4 = 2 --export: Altitude Hold Preset 4\ndeviationThreshold = 0.5 --export: Deviation tolerace in m\ninertialDampening = true --export: Start with inertial dampening on/off\nfollowGravity = true --export: Start with gravity follow on/off\nminRotationSpeed = 0.01 --export: Minimum speed rotation scales from\nmaxRotationSpeed = 5 --export: Maximum speed rotation scales to\nrotationStep = 0.03 --export: Depermines how quickly rotation scales up\nverticalSpeedLimitAtmo = 1100 --export: Vertical speed limit in atmosphere\nverticalSpeedLimitSpace = 4000 --export: Vertical limit in space\napproachSpeed = 200 --export: Max final approach speed\nautoShutdown = true --export: Auto shutoff on RTB landing\nbreadCrumbDist = 1000 --export: Distance of vector breadcrumbs for elevator control\nContainerOptimization = 5 --export: Container ContainerOptimization\nFuelTankOptimization = 5 --export: Fuel Tank FuelTankOptimization\nfuelTankHandlingAtmo = 5 --export: Fuel Tank Handling Atmo\nfuelTankHandlingSpace = 5 --export: Fuel Tank Handling Space\n\nprimaryColor = \"b80000\" --export: Primary color of HUD\nsecondaryColor = \"e30000\" --export: Secondary color of HUD\ntextShadow = \"e81313\" --export: Color of text shadow for speedometer\nARCrosshair = \"ebbb0c\" --export: Color of the AR crosshair\nfuelFontSize = 1.8 --export: Fuel Gauge Font Size\n\n\nshowDockingWidget = true --export: Show Docking Widget\ndockingMode = 1 --export: Set docking mode (1:Manual, 2:Automatic, 3:Semi-Automatic)\nsetBaseOnStart = false --export: Set RTB location on start\nuseGEAS = false --export:\nGEAS_Alt = 10 --export:\nactivateFFonStart = false\nsetactivateFFonStart = false --export: Activate force fields on start (connected to button)\npocket = false\nsetpocket = false --export: Pocket ship?\nmouseSensitivity = 1 --export: Enter your mouse sensativity setting\nenableARReticle = false --export: Enable AR reticle\n\nlockVerticalToBase = false --export: FOR ELEVATORS ONLY\n\n\n--charMovement = true --export: Enable/Disable Character Movement\nbool_to_number={ [true]=1, [false]=0 }\nnumber_to_bool={ [1]=true, [0]=false }\n  \nif flightModeDb.hasKey(\"activateFFonStart\") == 0 or updateSettings then \n    flightModeDb.setIntValue(\"activateFFonStart\", bool_to_number[setactivateFFonStart])\n    activateFFonStart = setactivateFFonStart\nelse activateFFonStart = number_to_bool[flightModeDb.getIntValue(\"activateFFonStart\")] end\n\n\n\nif flightModeDb.hasKey(\"lockVerticalToBase\") == 0 or updateSettings then \n    flightModeDb.setIntValue(\"lockVerticalToBase\", bool_to_number[lockVerticalToBase])\nelse lockVerticalToBase = number_to_bool[flightModeDb.getIntValue(\"lockVerticalToBase\")] end\n\nif flightModeDb.hasKey(\"pocket\") == 0 or updateSettings then \n    flightModeDb.setIntValue(\"pocket\", bool_to_number[setpocket])\n    pocket = setpocket\nelse pocket = number_to_bool[flightModeDb.getIntValue(\"pocket\")] end\n\n--system.print(\"pocket: \"..number_to_bool[flightModeDb.getIntValue(\"pocket\")])",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "1"
    },
    {
      "code": "--@class PlanetRef\nfunction PlanetRef()\n    local function isNumber(n)  return type(n)           == 'number' end\n    local function isSNumber(n) return type(tonumber(n)) == 'number' end\n    local function isTable(t)   return type(t)           == 'table'  end\n    local function isString(s)  return type(s)           == 'string' end\n    local function isVector(v)  return isTable(v)\n                                        and isNumber(v.x and v.y and v.z) end\n\n    local function isMapPosition(m) return isTable(m) and isNumber(m.latitude  and\n                                                                m.longitude and\n                                                                m.altitude  and\n                                                                m.bodyId    and\n                                                                m.systemId) end\n\n    -- Constants\n\n    local deg2rad    = math.pi/180\n    local rad2deg    = 180/math.pi\n    local epsilon    = 1e-10\n    local num        = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\n    local posPattern = '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' ..\n                    num ..  ',' .. num .. '}'\n\n    -- Utilities\n\n    local utils  = require('cpml.utils')\n    local vec3   = require('cpml.vec3')\n    local clamp  = utils.clamp\n\n    local function float_eq(a,b)\n        if a == 0 then return math.abs(b) < 1e-09 end\n        if b == 0 then return math.abs(a) < 1e-09 end\n        return math.abs(a - b) < math.max(math.abs(a),math.abs(b))*epsilon\n    end\n\n    local function formatNumber(n)\n        local result = string.gsub(\n                        string.reverse(string.format('%.4f',n)),\n                        '^0*%.?','')\n        return result == '' and '0' or string.reverse(result)\n    end\n\n    local function formatValue(obj)\n        if isVector(obj) then\n            return string.format('{x=%.3f,y=%.3f,z=%.3f}', obj.x, obj.y, obj.z)\n        end\n\n        if isTable(obj) and not getmetatable(obj) then\n            local list = {}\n            local nxt  = next(obj)\n\n            if type(nxt) == 'nil' or nxt == 1 then -- assume this is an array\n                for i,a in ipairs(obj) do\n                    list[i] = formatValue(a)\n                end\n            else\n                for k,v in pairs(obj) do\n                    local value = formatValue(v)\n                    if type(k) == 'number' then\n                        table.insert(list, string.format('[%s]=%s', k, value))\n                    else\n                        table.insert(list, string.format('%s=%s',   k, value))\n                    end\n                end\n            end\n            return string.format('{%s}', table.concat(list, ','))\n        end\n\n        if isString(obj) then\n            return string.format(\"[[%s]]\", obj)\n        end\n        return tostring(obj)\n    end\n\n    -- CLASSES\n\n    -- BodyParameters: Attributes of planetary bodies (planets and moons)\n\n    local BodyParameters = {}\n    BodyParameters.__index = BodyParameters\n    BodyParameters.__tostring =\n        function(obj, indent)\n            local keys = {}\n            for k in pairs(obj) do table.insert(keys, k) end\n            table.sort(keys)\n            local list = {}\n            for _, k in ipairs(keys) do\n                local value = formatValue(obj[k])\n                if type(k) == 'number' then\n                    table.insert(list, string.format('[%s]=%s', k, value))\n                else\n                    table.insert(list, string.format('%s=%s', k, value))\n                end\n            end\n            if indent then\n                return string.format('%s%s',\n                                    indent,\n                                    table.concat(list, ',\\n' .. indent))\n            end\n            return string.format('{%s}', table.concat(list, ','))\n        end\n    BodyParameters.__eq = function(lhs, rhs)\n            return lhs.planetarySystemId == rhs.planetarySystemId and\n                lhs.bodyId            == rhs.bodyId            and\n                float_eq(lhs.radius, rhs.radius)               and\n                float_eq(lhs.center.x, rhs.center.x)           and\n                float_eq(lhs.center.y, rhs.center.y)           and\n                float_eq(lhs.center.z, rhs.center.z)           and\n                float_eq(lhs.GM, rhs.GM)\n        end\n\n    local function mkBodyParameters(systemId, bodyId, radius, worldCoordinates, GM)\n        -- 'worldCoordinates' can be either table or vec3\n        assert(isSNumber(systemId),\n            'Argument 1 (planetarySystemId) must be a number:' .. type(systemId))\n        assert(isSNumber(bodyId),\n            'Argument 2 (bodyId) must be a number:' .. type(bodyId))\n        assert(isSNumber(radius),\n            'Argument 3 (radius) must be a number:' .. type(radius))\n        assert(isTable(worldCoordinates),\n            'Argument 4 (worldCoordinates) must be a array or vec3.' ..\n            type(worldCoordinates))\n        assert(isSNumber(GM),\n            'Argument 5 (GM) must be a number:' .. type(GM))\n        return setmetatable({planetarySystemId = tonumber(systemId),\n                            bodyId            = tonumber(bodyId),\n                            radius            = tonumber(radius),\n                            center            = vec3(worldCoordinates),\n                            GM                = tonumber(GM) }, BodyParameters)\n    end\n\n    -- MapPosition: Geographical coordinates of a point on a planetary body.\n\n    local MapPosition = {}\n    MapPosition.__index = MapPosition\n    MapPosition.__tostring = function(p)\n            return string.format('::pos{%d,%d,%s,%s,%s}',\n                                p.systemId,\n                                p.bodyId,\n                                formatNumber(p.latitude*rad2deg),\n                                formatNumber(p.longitude*rad2deg),\n                                formatNumber(p.altitude))\n        end\n    MapPosition.__eq       = function(lhs, rhs)\n            return lhs.bodyId   == rhs.bodyId              and\n                lhs.systemId == rhs.systemId            and\n                float_eq(lhs.latitude,   rhs.latitude)  and\n                float_eq(lhs.altitude,   rhs.altitude)  and\n                (float_eq(lhs.longitude, rhs.longitude) or\n                    float_eq(lhs.latitude, math.pi/2)      or\n                    float_eq(lhs.latitude, -math.pi/2))\n        end\n\n    -- latitude and longitude are in degrees while altitude is in meters\n\n    local function mkMapPosition(overload, bodyId, latitude, longitude, altitude)\n        local systemId = overload -- Id or '::pos{...}' string\n\n        if isString(overload) and not longitude and not altitude and\n                                not bodyId    and not latitude then\n            systemId, bodyId, latitude, longitude, altitude =\n                                                string.match(overload, posPattern)\n            assert(systemId, 'Argument 1 (position string) is malformed.')\n        else\n            assert(isSNumber(systemId),\n                'Argument 1 (systemId) must be a number:' .. type(systemId))\n            assert(isSNumber(bodyId),\n                'Argument 2 (bodyId) must be a number:' .. type(bodyId))\n            assert(isSNumber(latitude),\n                'Argument 3 (latitude) must be in degrees:' .. type(latitude))\n            assert(isSNumber(longitude),\n                'Argument 4 (longitude) must be in degrees:' .. type(longitude))\n            assert(isSNumber(altitude),\n                'Argument 5 (altitude) must be in meters:' .. type(altitude))\n        end\n        systemId  = tonumber(systemId)\n        bodyId    = tonumber(bodyId)\n        latitude  = tonumber(latitude)\n        longitude = tonumber(longitude)\n        altitude  = tonumber(altitude)\n\n        if bodyId == 0 then -- this is a hack to represent points in space\n            return setmetatable({latitude  = latitude,\n                                longitude = longitude,\n                                altitude  = altitude,\n                                bodyId    = bodyId,\n                                systemId  = systemId}, MapPosition)\n        end\n        return setmetatable({latitude  = deg2rad*clamp(latitude, -90, 90),\n                            longitude = deg2rad*(longitude % 360),\n                            altitude  = altitude,\n                            bodyId    = bodyId,\n                            systemId  = systemId}, MapPosition)\n    end\n\n    -- PlanetarySystem - map body IDs to BodyParameters\n\n    local PlanetarySystem = {}\n    PlanetarySystem.__index = PlanetarySystem\n\n    PlanetarySystem.__tostring =\n        function (obj, indent)\n            local sep = indent and (indent .. '  ' )\n            local bdylist = {}\n            local keys = {}\n            for k in pairs(obj) do table.insert(keys, k) end\n            table.sort(keys)\n            for _, bi in ipairs(keys) do\n                bdy = obj[bi]\n                local bdys = BodyParameters.__tostring(bdy, sep)\n                if indent then\n                    table.insert(bdylist,\n                                string.format('[%s]={\\n%s\\n%s}',\n                                            bi, bdys, indent))\n                else\n                    table.insert(bdylist, string.format('  [%s]=%s', bi, bdys))\n                end\n            end\n            if indent then\n                return string.format('\\n%s%s%s',\n                                    indent,\n                                    table.concat(bdylist, ',\\n' .. indent),\n                                    indent)\n            end\n            return string.format('{\\n%s\\n}', table.concat(bdylist, ',\\n'))\n        end\n\n    local function mkPlanetarySystem(systemReferenceTable)\n        local atlas = {}\n        local pid\n        for _, v in pairs(systemReferenceTable) do\n            local id = v.planetarySystemId\n\n            if id == nil then\n                id = 0\n                v.planetarySystemId = id\n            end\n\n            if type(id) ~= 'number' then\n                error('Invalid planetary system ID: ' .. tostring(id))\n            elseif pid and id ~= pid then\n                error('Mismatch planetary system IDs: ' .. id .. ' and '\n                    .. pid)\n            end\n            local bid = v.bodyId\n\n            if bid == nil then\n                bid      = v.id\n                v.bodyId = bid\n            end\n            if type(bid) ~= 'number' then\n                error('Invalid body ID: ' .. tostring(bid))\n            elseif atlas[bid] then\n                error('Duplicate body ID: ' .. tostring(bid))\n            end\n            v.center = vec3(v.center)\n            atlas[bid] = setmetatable(v, BodyParameters)\n            pid = id\n        end\n        return setmetatable(atlas, PlanetarySystem)\n    end\n\n    -- PlanetaryReference - map planetary system ID to PlanetarySystem\n\n    PlanetaryReference = {}\n\n    local function mkPlanetaryReference(referenceTable)\n        return setmetatable({ galaxyAtlas = referenceTable or {} },\n                            PlanetaryReference)\n    end\n\n    PlanetaryReference.__index        = \n        function(t,i)\n            if type(i) == 'number' then\n                local system = t.galaxyAtlas[i]\n                return mkPlanetarySystem(system)\n            end\n            return rawget(PlanetaryReference, i)\n        end\n    PlanetaryReference.__pairs        =\n        function(obj)\n            return  function(t, k)\n                        local nk, nv = next(t, k)\n                        return nk, nv and mkPlanetarySystem(nv)\n                    end, obj.galaxyAtlas, nil\n        end\n    PlanetaryReference.__tostring     =\n        function (obj)\n            local pslist = {}\n            for _,ps in pairs(obj or {}) do\n                local psi = ps:getPlanetarySystemId()\n                local pss = PlanetarySystem.__tostring(ps, '    ')\n                table.insert(pslist,\n                            string.format('  [%s]={%s\\n  }', psi, pss))\n            end\n            return string.format('{\\n%s\\n}\\n', table.concat(pslist,',\\n'))\n        end\n    PlanetaryReference.BodyParameters = mkBodyParameters\n    PlanetaryReference.MapPosition    = mkMapPosition\n    PlanetaryReference.PlanetarySystem = mkPlanetarySystem\n\n    function PlanetaryReference.createBodyParameters(planetarySystemId,\n                                                    bodyId,\n                                                    surfaceArea,\n                                                    aPosition,\n                                                    verticalAtPosition,\n                                                    altitudeAtPosition,\n                                                    gravityAtPosition)\n        assert(isSNumber(planetarySystemId),\n            'Argument 1 (planetarySystemId) must be a number:' ..\n            type(planetarySystemId))\n        assert(isSNumber(bodyId),\n            'Argument 2 (bodyId) must be a number:' .. type(bodyId))\n        assert(isSNumber(surfaceArea),\n            'Argument 3 (surfaceArea) must be a number:' .. type(surfaceArea))\n        assert(isTable(aPosition),\n            'Argument 4 (aPosition) must be an array or vec3:' ..\n            type(aPosition))\n        assert(isTable(verticalAtPosition),\n            'Argument 5 (verticalAtPosition) must be an array or vec3:' ..\n            type(verticalAtPosition))\n        assert(isSNumber(altitudeAtPosition),\n            'Argument 6 (altitude) must be in meters:' ..\n            type(altitudeAtPosition))\n        assert(isSNumber(gravityAtPosition),\n            'Argument 7 (gravityAtPosition) must be number:' ..\n            type(gravityAtPosition))\n        local radius   = math.sqrt(surfaceArea/4/math.pi)\n        local distance = radius + altitudeAtPosition\n        local center   = vec3(aPosition) + distance*vec3(verticalAtPosition)\n        local GM       = gravityAtPosition * distance * distance\n        return mkBodyParameters(planetarySystemId, bodyId, radius, center, GM)\n    end\n    PlanetaryReference.isMapPosition  = isMapPosition\n    function PlanetaryReference:getPlanetarySystem(overload)\n        if self.galaxyAtlas then\n            local planetarySystemId = overload\n\n            if isMapPosition(overload) then\n                planetarySystemId = overload.systemId\n            end\n\n            if type(planetarySystemId) == 'number' then\n                local system = self.galaxyAtlas[planetarySystemId]\n                if system then\n                    if getmetatable(system) ~= PlanetarySystem then\n                        system = mkPlanetarySystem(system)\n                    end\n                    return system\n                end\n            end\n        end\n        return nil\n    end\n\n    function PlanetarySystem:castIntersections(origin,\n                                            direction,\n                                            sizeCalculator,\n                                            bodyIds)\n        local sizeCalculator = sizeCalculator or \n                                function (body) return 1.05*body.radius end\n        local candidates = {}\n\n        if bodyIds then\n            for _,i in ipairs(bodyIds) do candidates[i] = self[i] end\n        else\n            bodyIds = {}\n            for k,body in pairs(self) do\n                table.insert(bodyIds, k)\n                candidates[k] = body\n            end\n        end\n        local function compare(b1,b2)\n            local v1 = candidates[b1].center - origin\n            local v2 = candidates[b2].center - origin\n            return v1:len() < v2:len()\n        end\n        table.sort(bodyIds, compare)\n        local dir = direction:normalize()\n\n        for i, id in ipairs(bodyIds) do\n            local body   = candidates[id]\n            local c_oV3  = body.center - origin\n            local radius = sizeCalculator(body)\n            local dot    = c_oV3:dot(dir)\n            local desc   = dot^2 - (c_oV3:len2() - radius^2)\n\n            if desc >= 0 then\n                local root     = math.sqrt(desc)\n                local farSide  = dot + root\n                local nearSide = dot - root\n                if nearSide > 0 then\n                    return body, farSide, nearSide\n                elseif farSide > 0 then\n                    return body, farSide, nil\n                end\n            end\n        end\n        return nil, nil, nil\n    end\n\n    function PlanetarySystem:closestBody(coordinates)\n        assert(type(coordinates) == 'table', 'Invalid coordinates.')\n        local minDistance2, body\n        local coord = vec3(coordinates)\n\n        for _,params in pairs(self) do\n            local distance2 = (params.center - coord):len2()\n            if not body or distance2 < minDistance2 then\n                body         = params\n                minDistance2 = distance2\n            end\n        end\n        return body\n    end\n\n    function PlanetarySystem:convertToBodyIdAndWorldCoordinates(overload)\n        local mapPosition = overload\n        if isString(overload) then\n            mapPosition = mkMapPosition(overload)\n        end\n\n        if mapPosition.bodyId == 0 then\n            return 0, vec3(mapPosition.latitude,\n                        mapPosition.longitude,\n                        mapPosition.altitude)\n        end\n        local params = self:getBodyParameters(mapPosition)\n\n        if params then\n            return mapPosition.bodyId,\n                params:convertToWorldCoordinates(mapPosition)\n        end\n    end\n\n    function PlanetarySystem:getBodyParameters(overload)\n        local bodyId = overload\n\n        if isMapPosition(overload) then\n            bodyId = overload.bodyId\n        end\n        assert(isSNumber(bodyId),\n                'Argument 1 (bodyId) must be a number:' .. type(bodyId))\n\n        return self[bodyId]\n    end\n\n    function PlanetarySystem:getPlanetarySystemId()\n        local k, v = next(self)\n        return v and v.planetarySystemId\n    end\n\n    function PlanetarySystem:netGravity(coordinates)\n        assert(type(coordinates) == 'table', 'Invalid coordinates.')\n        local netGravity   = vec3()\n        local coord        = vec3(coordinates)\n        local maxG, body\n\n        for _,params in pairs(self) do\n            local radial   = params.center - coord\n            local len2     = radial:len2()\n            local g        = params.GM/len2\n            if not body or g > maxG then\n                body       = params\n                maxG       = g\n            end\n            netGravity = netGravity + g/math.sqrt(len2)*radial\n        end\n        return body, netGravity\n    end\n\n    function BodyParameters:convertToMapPosition(worldCoordinates)\n        assert(isTable(worldCoordinates),\n            'Argument 1 (worldCoordinates) must be an array or vec3:' ..\n            type(worldCoordinates))\n        local worldVec  = vec3(worldCoordinates) \n\n        if self.bodyId == 0 then\n            return setmetatable({latitude  = worldVec.x,\n                                longitude = worldVec.y,\n                                altitude  = worldVec.z,\n                                bodyId    = 0,\n                                systemId  = self.planetarySystemId}, MapPosition)\n        end\n        local coords    = worldVec - self.center\n        local distance  = coords:len()\n        local altitude  = distance - self.radius\n        local latitude  = 0\n        local longitude = 0\n\n        if not float_eq(distance, 0) then\n            local phi = math.atan(coords.y, coords.x)\n            longitude = phi >= 0 and phi or (2*math.pi + phi)\n            latitude  = math.pi/2 - math.acos(coords.z/distance)\n        end\n        return setmetatable({latitude  = latitude,\n                            longitude = longitude,\n                            altitude  = altitude,\n                            bodyId    = self.bodyId,\n                            systemId  = self.planetarySystemId}, MapPosition)\n    end\n\n    function BodyParameters:convertToWorldCoordinates(overload)\n        local mapPosition = isString(overload) and\n                                            mkMapPosition(overload) or overload\n        if mapPosition.bodyId == 0 then -- support deep space map position\n            return vec3(mapPosition.latitude,\n                        mapPosition.longitude,\n                        mapPosition.altitude)\n        end\n        assert(isMapPosition(mapPosition),\n            'Argument 1 (mapPosition) is not an instance of \"MapPosition\".')\n        assert(mapPosition.systemId == self.planetarySystemId,\n            'Argument 1 (mapPosition) has a different planetary system ID.')\n        assert(mapPosition.bodyId == self.bodyId,\n            'Argument 1 (mapPosition) has a different planetary body ID.')\n        local xproj = math.cos(mapPosition.latitude)\n        return self.center + (self.radius + mapPosition.altitude) *\n            vec3(xproj*math.cos(mapPosition.longitude),\n                    xproj*math.sin(mapPosition.longitude),\n                    math.sin(mapPosition.latitude))\n    end\n\n    function BodyParameters:getAltitude(worldCoordinates)\n        return (vec3(worldCoordinates) - self.center):len() - self.radius\n    end\n\n    function BodyParameters:getDistance(worldCoordinates)\n        return (vec3(worldCoordinates) - self.center):len()\n    end\n\n    function BodyParameters:getGravity(worldCoordinates)\n        local radial = self.center - vec3(worldCoordinates) -- directed towards body\n        local len2   = radial:len2()\n        return (self.GM/len2) * radial/math.sqrt(len2)\n    end\n\n    return setmetatable(PlanetaryReference,\n                        { __call = function(_,...)\n                                        return mkPlanetaryReference(...)\n                                end })\nend",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "2"
    },
    {
      "code": "--@class KinematicsMin\nfunction Kinematics()local a={}local b=30000000/3600;local c=b*b;local d=100;local function e(f)return 1/math.sqrt(1-f*f/c)end;function a.computeAccelerationTime(g,h,i)local j=b*math.asin(g/b)return(b*math.asin(i/b)-j)/h end;function a.computeDistanceAndTime(g,i,k,l,m,n)m=m or 0;n=n or 0;local o=e(g)local p=g<=i;local q=l*(p and 1 or-1)/k;local r=-n/k;local s=q+r;if p and s<=0 or not p and s>=0 then return-1,-1 end;local t,u=0,0;if q~=0 and m>0 then local j=math.asin(g/b)local v=math.pi*(q/2+r)local w=q*m;local x=b*math.pi;local f=function(y)local z=(v*y-w*math.sin(math.pi*y/2/m)+x*j)/x;local A=math.tan(z)return b*A/math.sqrt(A*A+1)end;local B=p and function(C)return C>=i end or function(C)return C<=i end;u=2*m;if B(f(u))then local D=0;while math.abs(u-D)>0.5 do local y=(u+D)/2;if B(f(y))then u=y else D=y end end end;local E=g;local F=u/d;for G=1,d do local H=f(G*F)t=t+(H+E)*F/2;E=H end;if u<2*m then return t,u end;g=E end;local j=b*math.asin(g/b)local I=(b*math.asin(i/b)-j)/s;local J=c*math.cos(j/b)/s;local K=J-c*math.cos((s*I+j)/b)/s;return K+t,I+u end;function a.computeTravelTime(g,h,K)if K==0 then return 0 end;if h>0 then local j=b*math.asin(g/b)local J=c*math.cos(j/b)/h;return(b*math.acos(h*(J-K)/c)-j)/h end;assert(g>0,'Acceleration and initial speed are both zero.')return K/g end;function a.lorentz(f)return e(f)end;return a end",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "3"
    },
    {
      "code": "--@class Serializer\nlocal concat = table.concat\nlocal sFormat = string.format\nlocal function internalSerialize(v,tC,t) local check = type(v) local intSerial=internalSerialize if check=='table' then t[tC]='{' local tempC=tC+1 if #v==0 then for k,e in pairs(v) do if type(k)~='number' then t[tempC]=k t[tempC+1]='=' tempC=tempC+2 else t[tempC]='[' t[tempC+1]=k t[tempC+2]=']=' tempC=tempC+3 end tempC=intSerial(e,tempC,t) t[tempC]=',' tempC=tempC+1 end else for k,e in pairs(v) do tempC=intSerial(e,tempC,t) t[tempC]=',' tempC=tempC+1 end end if tempC==(tC+1) then t[tempC]='}' return tempC+1 else t[tempC-1]='}' return tempC end elseif check=='string' then t[tC]=sFormat(\"%q\",v) return tC+1 elseif check=='number' then t[tC]=tostring(v) return tC+1 else t[tC]=v and 'true' or 'false' return tC+1 end end \nfunction serialize(v) local t={} local tC=1 local check = type(v) local intSerial=internalSerialize if check=='table' then t[tC]='{' tC=tC+1 local tempC=tC if #v==0 then for k,e in pairs(v) do if type(k)~='number' then t[tempC]=k t[tempC+1]='=' tempC=tempC+2 else t[tempC]='[' t[tempC+1]=k t[tempC+2]=']=' tempC=tempC+3 end tempC=intSerial(e,tempC,t) t[tempC]=',' tempC=tempC+1 end else for k,e in pairs(v) do tempC=intSerial(e,tempC,t) t[tempC]=',' tempC=tempC+1 end end if tempC==tC then t[tempC]='}' else t[tempC-1]='}' end elseif check=='string' then t[tC]=sFormat(\"%q\",v) elseif check=='number' then t[tC]=tostring(v) else t[tC]=v and 'true' or 'false' end return concat(t) end\nfunction deserialize(s) local f=load('t='..s) f() return t end\nfunction tryDeserialize(s) local f=load('t='..s) if f then f() return true, t else return false end end\nfunction mToKm(n)\n    if n >= 1000 then\n        return round2((n / 1000),2) .. \" km\"\n    else\n        return round2(n,2) .. \" m\"\n    end\nend\nfunction round2(num, numDecimalPlaces)\n    if num ~= nil then\n    return tonumber(string.format(\"%.\" .. (numDecimalPlaces or 0) .. \"f\", num))\n        end\nend\nconfig = {\n    dataType = \"config\",\n    floors = {\n        floor1 = 0,\n        floor2 = 0,\n        floor3 = 0,\n        floor4 = 0,\n    },\n    elevatorName = construct.getName(),\n    rtb = 0,\n    targetAlt = 0,\n    estop = false,\n    settingsActive = false,\n    setBaseActive = false,\n    setBaseReq = false,\n    manualControl = false,\n    destination = nil,\n    shutDown = false,\n    updateReq = false,\n    }\n\nstats = {\n        dataType = \"stats\",\n            data = {\n                elevation = 0,\n                target = config.targetAlt,\n                velocity = 0,\n                mass = 0,\n                gravity = 0,\n                target_dist = 0,\n                brake_dist = 0,\n                deviation = 0,\n                deviationVec = vec3(0,0,0),\n                deviationRot = vec3(0,0,0),\n                state = \"Idle\",\n        }\n    }\nfuelAtmo = {\n    dataType = \"fuelAtmo\",\n    tanks = {}\n}\n\nfuelSpace = {\n    dataType = \"fuelSpace\",\n    tanks = {}\n}\n\nfunction fuelTank(tm,pct)\n    local mt = {}\n    mt.__index = mt\n    return setmetatable({\n            tm = tm,\n            pct = pct\n        },mt)\nend",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "4"
    },
    {
      "code": "--@class EventDelegateMin\nfunction EventDelegate()local a={}a.Delegates={}function a.Add(b)if type(b)~=\"function\"then error(\"[EventDelegate] Unable to add callback - not a function\")return end;for c=1,#a.Delegates do if a.Delegates[c]==b then return false end end;table.insert(a.Delegates,b)return true end;function a.Remove(b)if type(b)~=\"function\"then error(\"[EventDelegate] Unable to remove callback - not a function\")return end;for c=1,#a.Delegates do if a.Delegates[c]==b then table.remove(a.Delegates,c)return true end end;return false end;function a.Call(...)for c=1,#a.Delegates do a.Delegates[c](...)end end;function a.Count()return#a.Delegates end;setmetatable(a,{__call=function(d,...)a.Call(...)end,__add=function(e,f)if e==a then a.Add(f)return a end;if f==a then a.Add(e)return a end;return a end,__sub=function(e,f)if e==a then a.Remove(f)return a end;if f==a then a.Remove(e)return a end;return a end,__tostring=function()return\"EventDelegate(#\"..#a.Delegates..\")\"end})return a end;Events={Update=EventDelegate(),Flush=EventDelegate()}",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "5"
    },
    {
      "code": "--@class TaskManagerMin\nTaskManager=(function()local self={}self.Stack={}function self.Register(a)if not a.Coroutine then error(\"[TaskManager] Trying to register a non-Task\")end;table.insert(self.Stack,a)end;function self.Update()for b=1,#self.Stack do local a=self.Stack[b]if a and a.Coroutine~=nil then if coroutine.status(a.Coroutine)~=\"dead\"then local c,d=coroutine.resume(a.Coroutine)a.Error=not c;a.LastReturn=d else table.remove(self.Stack,b)if a.Error and a._Catch then a._Catch(a.LastReturn)elseif a._Then~=nil then a._Then(a.LastReturn)end;if a._Finally~=nil then a._Finally()end;a.Finished=true end end end end;return self end)()function Task(e)local self={}self.LastReturn=nil;self.Error=nil;self.Finished=false;if type(e)~=\"function\"then error(\"[Task] Not a function.\")end;self.Coroutine=coroutine.create(e)function self.Then(e)if type(e)~=\"function\"then error(\"[Task] Then callback not a function.\")end;self._Then=e;return self end;function self.Finally(e)if type(e)~=\"function\"then error(\"[Task] Finally callback not a function.\")end;self._Finally=e;return self end;function self.Catch(e)if type(e)~=\"function\"then error(\"[Task] Catch callback not a function.\")end;self._Catch=e;return self end;TaskManager.Register(self)return self end;function await(a)if not a or not a.Coroutine then error(\"Trying to await non-task object\")end;while not a.Finished do coroutine.yield()end;return a.LastReturn end",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "6"
    },
    {
      "code": "--@class DynamicDocumentMin\nfunction DynamicDocument(a)local self={}self.template=a or\"\"local b=\"\"local c={}self.tree={}local d={br=true,hr=true,img=true,embed=true,param=true,area=true,col=true,input=true,meta=true,link=true,base=true,basefont=true,iframe=true,isindex=true,circle=true,polygon=true,polyline=true,ellipse=true,path=true,line=true,rect=true,use=true}function table.indexOf(val,table)for e,f in ipairs(table)do if f==val then return e end end;return nil end;function self.makeFunc(string)local val=\"nil\"if c[string]==nil then local g,h=pcall(load(\"return function() return \"..string..\" end\",nil,\"t\",_ENV))if g then c[string]=h;val=h()if type(val)==\"function\"then c[string]=h()val=val()end end else val=c[string]()end;return val end;local function i(a)local j=0;local k={}local l={}l.dd={}table.insert(k,l)local node={}for m,n,o,p,q,r,val,s in string.gmatch(a,\"(<)(%/?!?)([%w:_-'\\\\\\\"%[]+)(.-)(%/?%-?)>([%s\\r\\n\\t]*)([^<]*)([%s\\r\\n\\t]*)\")do o=string.lower(o)if n==\"/\"then if j==0 then return l end;j=j-1;table.remove(k)else local function t(u)local v=\"dd-\"return u:sub(1,#v)==v end;j=j+1;node={}node.name=o;node.children={}node.attr={}if k[j-1]then node.parent=k[j-1][#k[j-1]]else node.parent=nil end;if p~=\"\"then for w,f in string.gmatch(p,\"%s([^%s=]+)=\\\"([^\\\"]+)\\\"\")do node.attr[w]=string.gsub(f,'\"','[^\\\\]\\\\\"')if t(w)then if not l.dd[w]then l.dd[w]={}end;table.insert(l.dd[w],node)end end;for w,f in string.gmatch(p,\"%s([^%s=]+)='([^']+)'\")do node.attr[w]=string.gsub(f,'\"','[^\\\\]\\\\\"')if t(w)then if not l.dd[w]then l.dd[w]={}end;table.insert(l.dd[w],node)end end end;if not k[j]then k[j]={}end;table.insert(k[j],node)if d[o]then if val~=\"\"then table.insert(k[j],{name=\"textNode\",value=val})end;node.children={}j=j-1 else if val~=\"\"then table.insert(node.children,{name=\"textNode\",value=val})end;table.insert(k,node.children)end end end;return l end;local function x(y,z)local k={y}local A=\"\"local function B(C)local D=0;for E in pairs(C)do D=D+1 end;return D end;if not z and B(y.dd)>0 then if y.dd[\"dd-repeat\"]then for F=#y.dd[\"dd-repeat\"],1,-1 do local node=y.dd[\"dd-repeat\"][F]var,array=string.match(node.attr[\"dd-repeat\"],\"(.*) in (.*)\")node.attr[\"dd-repeat\"]=nil;local G=x({node},true)local H=string.gmatch(G,\"{{([^}}]+)}}\")local I={}for J in H do if string.match(J,var)then table.insert(I,J)end end;local b=\"\"local K=self.makeFunc(array)for F=1,#K do _ENV[var]=K[F]local L=G;local M=i(L:gsub(\"^%s*(.-)%s*$\",\"%1\"))b=b..x(M)end;node.children={}node.name=\"textNode\"node.value=b end end;if y.dd[\"dd-if\"]then for F=#y.dd[\"dd-if\"],1,-1 do local node=y.dd[\"dd-if\"][F]local N=self.makeFunc(node.attr[\"dd-if\"])if N then node.attr[\"dd-if\"]=nil else local O=table.indexOf(node,node.parent.children)if O then table.remove(node.parent.children,O)end;node=nil;table.remove(y.dd[\"dd-if\"],F)y.dd[\"dd-if\"][F]=nil end end end;if y.dd[\"dd-init\"]then for F=#y.dd[\"dd-init\"],1,-1 do local node=y.dd[\"dd-init\"][F]pcall(load(node.attr[\"dd-init\"],nil,\"t\",_ENV))node.attr[\"dd-init\"]=nil end end end;while#k~=0 do node=k[#k][1]if not node then break end;if node.name==\"textNode\"then local val=node.value:gsub(\"^%s*(.-)%s*$\",\"%1\")if not z then val=self.transformClosures(val)end;A=A..val else A=A..\"\\n\"..string.rep(\" \",#k-1)A=A..\"<\"..node.name;if node.attr then for P,f in pairs(node.attr)do if not z then P=self.transformClosures(P)f=self.transformClosures(f)end;A=A..\" \"..P..'=\"'..f..'\"'end end;if d[node.name]then A=A..\"/>\"else A=A..\">\"end end;if node.children and#node.children>0 then table.insert(k,node.children)else table.remove(k[#k],1)if node.children and#node.children==0 and not d[node.name]and not node.name==\"textNode\"then A=A..\"</\"..node.name..\">\"end;while#k>0 and#k[#k]==0 do table.remove(k)if#k>0 then if#k[#k][1].children>1 then A=A..\"\\n\"..string.rep(\" \",#k-1)..\"</\"..k[#k][1].name..\">\"else A=A..\"</\"..k[#k][1].name..\">\"end;table.remove(k[#k],1)end end end end;return A:match\"^%s*(.-)%s*$\"end;function self.transformClosures(Q)local R={}local S=string.gmatch(Q,\"{{([^}}]+)}}\")for F in S do table.insert(R,F)end;if#R>0 then for F=1,#R do local T=R[F]val=self.makeFunc(T)Q=string.gsub(Q,self.literalize(\"{{\"..T..\"}}\"),tostring(val))end end;return Q end;function self.literalize(u)return u:gsub(\"[%(%)%.%%%+%-%*%?%[%]%^%$]\",function(J)return\"%\"..J end)end;function self.Read()return x(i(self.template))end;return self end",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "7"
    },
    {
      "code": "--@class DUTTYMin\nDUTTY={}local a={}local b={}local function c(d,e)return d:sub(e,e)end;local function f(d)local g={}local h=false;local i=''local j=false;for k=1,#d do local l=c(d,k)if j==false and h and l==h then table.insert(g,i)h=false;i=''elseif j==false and#i==0 and(not h and(l=='\"'or l==\"'\"))then h=l elseif j==false and l==' 'and h==false then if#i>0 then table.insert(g,i)i=''end elseif j==false and l=='\\\\'then j=true else if j then j=false end;i=i..l end end;if#i>0 then table.insert(g,i)end;return g end;function DUTTY.input(d)for k,m in pairs(a)do if'function'==type(m)then m(d)end end;local n=f(d)if#n>0 then local o=''local p={}for k,d in pairs(n)do if k==1 then o=d:lower()else table.insert(p,d)end end;if b[o]and'function'==type(b[o])then b[o](table.unpack(p))end end end;function DUTTY.onInput(m)if not'function'==type(m)then error('Event handler must be of type function')end;table.insert(a,m)end;function DUTTY.onCommand(g,m)if not'function'==type(m)then error('Event handler must be of type function')end;b[g:lower()]=m end",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "8"
    },
    {
      "code": "--@class CSS_SHUD\ndisplaySize = 0.85\n\nsystem.print(fuelFontSize)\nCSS_SHUD = [[\n#horizon { \n  left: 0;\n  top: 0;\n  position: fixed;\n  width: 100vw;\n  height: 100vh;\n  background: radial-gradient(ellipse 27vw 11vw at 50% 51vw, rgba(1,5,8,0.6) 50%,rgba(1,5,8,0) 90%);\n  font-family: Verdana;\n  \n}\n\n#speedometer::before {\n  display: block;\n  position: absolute;\n  content: ' ';\n  top: 0.25vh;\n  bottom: -17vh;\n  left: 50%;\n  width: 31vw;\n  border: 10px solid #]]..primaryColor..[[;\n  border-bottom: 0;\n  border-right: 0;\n  border-left: 0;\n  border-radius: 100%;\n  transform: translateX(-50%);\n  background-color: transparent;\n  filter: blur(100vw);\n}\n\n#speedometerBar {\n  display: block;\n  position: fixed;\n  left: 50%;\n  top: 77.2vh;\n  width: 30vw;\n  height: 24.5vh;\n  transform: translate(-50%);\n  content: ' ';\n  border: 10px solid #]]..primaryColor..[[;\n  border-bottom: 0;\n  border-right: 0;\n  border-left: 0;\n  border-radius: 100%;\n  background-size: contain;\n  background-color: transparent;\n  filter: blur(0.1vw);\n}\n\n#speedometer {\n  font-family: 'Verdana';\n  font-weight: normal;\n  font-style: normal;\n  position: fixed;\n  left: 50%;\n  bottom: 13vh;\n  font-size: 2.5vw;\n  transform: translate(-50%);\n  background-color: transparent;\n  width: 30vw;\n  height: 10vh;\n  text-align: center;\n}\n\n#speedometer .display {\n  position: absolute;\n  top: calc(50% + 1vh);\n  left: calc(50% + 0.25em);\n  transform: translate(-50%, -50%);\n  font-weight: bold;\n  text-shadow: 0 0 0.75vw #]]..textShadow..[[;\n  padding: 0;\n  margin: 0;\n  font-size: 2.8vw;\n}\n\n#speedometer .display .minor, #speedometer .unit {\n  position: relative;\n  left: -0.5em;\n  vertical-align: super;\n  font-size: 40%;\n}\n\n#speedometer .unit {\n  vertical-align: 50%;\n  font-size: 23%;\n  left: -1.33em;\n}\n\n#speedometer .accel {\n  font-size: 1.2vw;\n  text-shadow: 0 0 0.15vw #000000;\n  position: absolute;\n  left: 12.5%;\n  bottom: 0;\n  opacity: 0.75;\n}\n\n#speedometer .accel .major::before {\n  content: 'Δ';\n  font-size: 40%;\n}\n\n#speedometer .accel .unit {\n  left: -0.66em;\n}\n\n#speedometer .alt {\n  position: absolute;\n  left: 50%;\n  bottom: -0.65vh;\n  transform: translateX(-50%);\n  font-size: 0.65vw;\n  text-align: center;\n}\n\n#speedometer .misc {\n  position: absolute;\n  left: 50%;\n  bottom: -1.5vh;\n  transform: translateX(-50%);\n  font-size: 0.4vw;\n  text-align: center;\n}\n\n#speedometer .throttle {\n  position: absolute;\n  left: 50%;\n  bottom: -4.3vh;\n  transform: translateX(-50%);\n  font-size: 0.7vw;\n  text-align: center;\n}\n\n#speedometer .vertical {\n  font-size: 1.3vw;\n  text-shadow: 0 0 0.15vw #000000;\n  position: absolute;\n  right: 12.5%;\n  bottom: 0;\n  opacity: 0.75;\n  text-align: right;\n}\n\n#speedometer .vertical::after {\n  content: '↕ m/s';\n  vertical-align: 50%;\n  font-size: 33%;\n}\n\n#speedometer::after {\n  display: block;\n  font-size: 0;\n  background-size: contain;\n  content: ' ';\n  position: absolute;\n  top: 0.5vh;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  z-index: 666;\n  opacity: 0.5;\n}\n\n#horizon-menu {\n  text-transform: uppercase;\n  font-family: 'Verdana';\n  font-size: ]] .. displaySize .. [[vw;\n  display: flex;\n  flex-direction: column;\n  position: fixed;\n  bottom: 35%;\n  left: 2vw;\n  width: 18vw;\n  padding: 1vw;\n  transform: perspective(50vw) rotateY(35deg);\n  text-shadow: 0.1vw 0 0.25vw #000000;\n}\n#horizon-menu .item {\n  color: #fff;\n  padding: 0.2vw 0.5vw;\n  z-index: 99999;\n}\n#horizon-menu .item .right {\n  float: right;\n}\n#horizon-menu .item .red {\n  color: #]]..secondaryColor..[[;\n}\n#horizon-menu .item.active {\n  position: relative;\n  text-shadow: 0 0 0.75vw #]]..secondaryColor..[[;\n  transform: translateZ(0.33vw);\n  font-size: 1.15em;\n  transform-style: preserve-3d;\n}\n\n#horizon-menu .item.active::before {\n  display: block;\n  content: ' ';\n  position: absolute;\n  top: 15%;\n  bottom: 15%;\n  left: 0.1vw;\n  right: 0.1vw;\n  background: #]]..secondaryColor..[[aa;\n  z-index: -50;\n  filter: blur(1vw);\n  opacity: 0.2;\n}\n\n#horizon-menu .item.active::after {\n  display: block;\n  content: ' ';\n  position: absolute;\n  top: 20%;\n  bottom: 40%;\n  left: 0.1vw;\n  right: 0.1vw;\n  background: #]]..secondaryColor..[[aa;\n  z-index: -50;\n  filter: blur(0.2vw);\n  opacity: 0.3; \n}\n#horizon-menu .item.locked {\n  padding-left: 0.4vw;\n}\n#horizon-menu .item.locked::before {\n  display: block;\n  content: ' ';\n  position: absolute;\n  top: 15%;\n  bottom: 15%;\n  left: 0.1vw;\n  right: 0.1vw;\n  background: #]]..primaryColor..[[aa;\n  z-index: -50;\n  filter: blur(1vw);\n  opacity: 0.2;\n}\n#horizon-menu .item.locked::after {\n  display: block;\n  content: ' ';\n  position: absolute;\n  top: 20%;\n  bottom: 40%;\n  left: 0.1vw;\n  right: 0.1vw;\n  background: #]]..primaryColor..[[aa;\n  z-index: -50;\n  filter: blur(0.2vw);\n  opacity: 0.6; \n}\n\n#horizon-menu::after {\n  content: ' ';\n  filter: blur(1vw);\n  display: block;\n  border-top-left-radius: 1vw;\n  border-top-right-radius: 1vw;\n  border-image: linear-gradient(to bottom, #]]..primaryColor..[[ff, #]]..primaryColor..[[00) 1 100%;\n  background: linear-gradient(to bottom, rgba(0,0,0,0.65) 50%,rgba(0,0,0,0) 100%);\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  z-index: -99;\n}\n\n#horizon-menu::before {\n  content: ' ';\n  filter: blur(0.05vw);\n  display: block;\n  border-top-left-radius: 1vw;\n  border-top-right-radius: 1vw;\n  border-top: 0.25vw solid #]]..primaryColor..[[;\n  border-left: 0.25vw solid #]]..primaryColor..[[;\n  border-right: 0.25vw solid #]]..primaryColor..[[;\n  border-image: linear-gradient(to bottom, #]]..primaryColor..[[ff, #]]..primaryColor..[[00) 1 100%;\n  background: radial-gradient(ellipse at top, rgba(0,0,0,0.65) 0%,rgba(0,0,0,0) 100%);\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  z-index: -100;\n}\n\n/* ORE TRILATERATE STYLE */\n\np {\n  /*color:#eca943;*/\n   font-size:100%;\n  }\n\n.block {\n  border: 1px solid DimGray;\n  border-radius:10px;\n  background-color: rgba(0,0,0,.5)\n  }\n\n#main_block{\n  text-align: center;\n  padding: 10px 10px 10px 10px;\n  }\n\n#help_block{\n  text-align: left;\n  padding: 10px 10px 10px 10px;\n  width: 320px;\n  }\t\n\n#pause_block{        \ntext-align: center;\n  font-size:90%;\n  }\n\n#panel_left {  \n  position: absolute;\n  top: 0%;\nleft: 0%;\n  /*width: 310px;*/\n\n  }\n#slider_header {\n  position: absolute;\n  top: 0vh;\n  font-size:110%;\nwidth: 100%;\ntext-align: center;\t   \n  }\n\n\n#slider_main {\n  position: relative;\n  font-size:105%;\ncolor:#eca943;\n  /*left: -51%;/*0%*/*/\n  }\n\n#slider_footer{\n  position: relative;\n  font-size:120%;\n  top:80%;\n  left:10%; \n  }\n\n#panel_slider {\n  position: absolute;\n  top: 54.5vh; ;\n  left: 66.8vw;/*66.8vw;*/\n  width: 9vw;/*9vw;*/\n  height: 28.5vh;\n  transform: skew(15.85deg); /*15.85deg*/\n  border-bottom: 28.5vh solid rgba(0,0,0,.25);\n  border-right: 1vw solid transparent;\n  /*background-color:rgba(0,0,0,.75)*/  \t\n  }\n\n#panel_test {  \n  position: fixed;\n  top: 100px; /* or whatever top you need */\nleft: 50%;\nwidth: auto;\n-webkit-transform: translateX(-50%);\n-moz-transform: translateX(-50%);\n-ms-transform: translateX(-50%);\n-o-transform: translateX(-50%);\ntransform: translateX(-50%);\n}\n#fuelTanks {\n  position: absolute;\n  top: 2%;\n  left: 2%;\n  width: 12vw;\n\n  color: #1b1b1b;\n  font-family: Verdana;\n  font-size: 1vh;\n  text-align: center;\n}\n#fuelTanks .fuel-meter {\n  display: block;\n  position: relative;\n  z-index: 1;\n  border-radius: 0.5em;\n  background: #c6c6c6;\n  padding: 0.5em 1em;\n  margin-bottom: 0.5em;\n  overflow: hidden;\n  box-sizing: border-box;\n}\n#fuelTanks .fuel-meter .fuel-level {\n  display: block;\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  bottom: 0px;\n  z-index: -1;\n  border: 0px none;\n  margin: 0;\n  padding: 0;\n}\n#fuelTanks .fuel-meter.fuel-type-atmo .fuel-level { background: #1dd1f9; }\n#fuelTanks .fuel-meter.fuel-type-space .fuel-level { background: #fac31e; }\n#fuelTanks .fuel-meter.fuel-type-rocket .fuel-level { background: #bfa6ff; }\n.st0{fill:none;stroke:#]]..ARCrosshair..[[;stroke-width:1;stroke-miterlimit:10;}\n.st1{fill:none;stroke:#]]..ARCrosshair..[[;stroke-width:2;stroke-miterlimit:10;}\n.st2{fill:#]]..ARCrosshair..[[;stroke:#]]..ARCrosshair..[[;stroke-miterlimit:10;}\n.st3{fill:#]]..ARCrosshair..[[; font-family: Verdana; font-size:10.5px;}\n.shadow {\n  -webkit-filter: drop-shadow( 3px 3px 2px rgba(0, 0, 0, .7));\n  filter: drop-shadow( 3px 3px 2px rgba(0, 0, 0, .7));\n}\n]]\n\n--system.print([[Shadow Templar Mining Chair H1R3<style>#custom_screen_click_layer{ display: none !important; }</style>]])",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "9"
    },
    {
      "code": "--@class FuelTankHelper\nsystem.print(\"ContainerOp\"..ContainerOptimization)\nfuelTanks = {}\nFuelMass = {}\nFuelTime = {}\nfuelTypes = {\n  atmo = {\n    density = 4.000,\n  },\n  space = {\n    density = 6.000,\n  },\n  rocket = {\n    density = 0.800,\n  },\n}\nlocal function calcAtmoVolume(baseCap)\n  if fuelTankHandlingAtmo > 0 then\n    return baseCap + (baseCap * (fuelTankHandlingAtmo * 0.2))\n  else\n    return baseCap\n  end\nend\nlocal function calcSpaceVolume(baseCap)\n  if fuelTankHandlingSpace > 0 then\n    return baseCap + (baseCap * (fuelTankHandlingSpace * 0.2))\n  else\n    return baseCap\n  end\nend\nlocal function calcMaxMass(cap, type)\n  local maxMass = cap * fuelTypes[type].density\n\n  local adjustedMaxMass = maxMass\n  if ContainerOptimization > 0 then adjustedMaxMass = maxMass - (maxMass * ContainerOptimization * 0.05) end\n  if FuelTankOptimization > 0 then adjustedMaxMass = adjustedMaxMass - (maxMass * FuelTankOptimization * 0.05) end\n\n  return adjustedMaxMass\nend\nfunction normalizeHp(type,hp)\n  local adjHp = 0\n\n  if type == \"atmo\" then \n    if hp >= 50 and hp < 163 then adjHp = 50\n    elseif hp >= 163 and hp < 1315 then adjHp = 163\n    elseif hp >= 1315 and hp < 10461 then adjHp = 1315\n    elseif hp >= 10461 then adjHp = 10461 end\n  elseif type == \"space\" then\n    if hp >= 50 and hp < 187 then adjHp = 50\n    elseif hp >= 187 and hp < 1496 then adjHp = 187\n    elseif hp >= 1496 and hp < 15933 then adjHp = 1496\n    elseif hp >= 15933 then adjHp = 15933 end\n  elseif type == \"rocket\" then\n    if hp >= 366 and hp < 736 then adjHp = 366\n    elseif hp >= 736 and hp < 6231 then adjHp = 736\n    elseif hp >= 6231 and hp < 68824 then adjHp = 6231\n    elseif hp >= 68824 then adjHp = 68824 end\n  end\n\n  return adjHp\nend\nfunction normalizeHpAtmo(hp)\n  \nend\nfunction normalizeHpSpace(hp)\n  -- 187\n  -- 1496\n  -- 15933\n  \nend\nfunction normalizeHpRocket(hp)\n  -- 366\n  -- 736\n  -- 6231\n  -- 68824\n  \nend\nfuelTankSpecsByMaxHP = {\n  -- Atmo Tanks\n  atmo = {\n    _50 = {\n      type = \"atmo\",\n      size = \"XS\",\n      capacity = function() return calcAtmoVolume(100) end,\n      baseWeight = 35.030,\n      maxWeight = function() return calcMaxMass(calcAtmoVolume(100),\"atmo\") end,\n    },\n    _163 = {\n      type = \"atmo\",\n      size = \"S\",\n      capacity = function() return calcAtmoVolume(400) end,\n      baseWeight = 182.670,\n      maxWeight = function() return calcMaxMass(calcAtmoVolume(400),\"atmo\") end,\n    },\n    _1315 = {\n      type = \"atmo\",\n      size = \"M\",\n      capacity = function() return calcAtmoVolume(1600) end,\n      baseWeight = 988.670,\n      maxWeight = function() return calcMaxMass(calcAtmoVolume(1600),\"atmo\") end,\n    },\n    _10461 = {\n      type = \"atmo\",\n      size = \"L\",\n      capacity = function() return calcAtmoVolume(12800) end,\n      baseWeight = 5480.000,\n      maxWeight = function() return calcMaxMass(calcAtmoVolume(12800),\"atmo\") end,\n    },\n  },\n\n  -- Space Tanks\n  space = {\n    _50 = {\n      type = \"space\",\n      size = \"XS\",\n      capacity = function() return calcAtmoVolume(100) end,\n      baseWeight = 35.030,\n      maxWeight = function() return calcMaxMass(calcAtmoVolume(100),\"space\") end,\n    },\n    _187 = {\n      type = \"space\",\n      size = \"S\",\n      capacity = function() return calcSpaceVolume(400) end,\n      baseWeight = 182.670,\n      maxWeight = function() return calcMaxMass(calcAtmoVolume(400),\"space\") end,\n    },\n    _1496 = {\n      type = \"space\",\n      size = \"M\",\n      capacity = function() return calcSpaceVolume(1600) end,\n      baseWeight = 988.670,\n      maxWeight = function() return calcMaxMass(calcAtmoVolume(1600),\"space\") end,\n    },\n    _15933 = {\n      type = \"space\",\n      size = \"L\",\n      capacity = function() return calcSpaceVolume(12800) end,\n      baseWeight = 5480.000,\n      maxWeight = function() return calcMaxMass(calcAtmoVolume(12800),\"space\") end,\n    },\n  },\n\n  -- Rocket Tanks\n  rocket = {\n    _366 = {\n      type = \"rocket\",\n      size = \"XS\",\n      capacity = function() return 400 end,\n      baseWeight = 173.420,\n      maxWeight = function() return calcMaxMass(calcAtmoVolume(400),\"rocket\") end,\n    },\n    _736 = {\n      type = \"rocket\",\n      size = \"S\",\n      capacity = function() return 800 end,\n      baseWeight = 886.720,\n      maxWeight = function() return calcMaxMass(calcAtmoVolume(800),\"rocket\") end,\n    },\n    _6231 = {\n      type = \"rocket\",\n      size = \"M\",\n      capacity = function() return 6400 end,\n      baseWeight = 4720.000,\n      maxWeight = function() return calcMaxMass(calcAtmoVolume(6400),\"rocket\") end,\n    },\n    _68824 = {\n      type = \"rocket\",\n      size = \"L\",\n      capacity = function() return 50000 end,\n      baseWeight = 25740.000,\n      maxWeight = function() return calcMaxMass(calcAtmoVolume(50000),\"rocket\") end,\n    },\n  },\n}\n\nlocal function isINF(value)\n  return value == math.huge or value == -math.huge\nend\n\nlocal function isNAN(value)\n  return value ~= value\nend\n\nfunction disp_time(time)\n  if isINF(time) or isNAN(time) then return \"inf\" end\n  local days = math.floor(time/86400)\n  local hours = math.floor(math.fmod(time, 86400)/3600)\n  local minutes = math.floor(math.fmod(time,3600)/60)\n  local seconds = math.floor(math.fmod(time,60))\n  if time >= 86400 then\n      return string.format(\"%dd:%02dh\",days,hours)\n  elseif time < 86400 and time > 3600 then\n      return string.format(\"%02dh:%02dm:%02ds\",hours,minutes,seconds)\n  elseif time < 3600 and time > 60 then\n      return string.format(\"%02dm:%02ds\",minutes,seconds)\n  else\n      return string.format(\"%02ds\",seconds)\n  end\nend\n\nlocal unpack = table.unpack\n\nfunction fuelUsed(period)\n\tlocal t = {}\n\tfunction sum(a, ...)\n\t\tif a then \n            return a-sum(...) \n        else \n            return 0 \n        end\n\tend\n\tfunction average(n)\n\t\tif #t == period then table.remove(t, 1) end\n\t\tif n ~= 0 and n ~= nil then t[#t + 1] = n end\n\t\treturn sum(unpack(t))\n\tend\n\treturn average\nend\n\n\n\nfunction getFuelSituation()\n  local tanks = {\n    atmo = {},\n    space = {},\n    rocket = {},\n  }\n\n  for id, specs in pairs(fuelTanks) do\n    table.insert(tanks[specs.type], {\n      name = core.getElementNameById(id),\n      level = getFuelTankLevel(id),\n      time = getFuelTime(id),\n      specs = specs,\n    })\n  end\n\n  return tanks\nend\n\nfunction getFuelTankSpecs(fuelTankType, fuelTankId)\n  local maxHP = math.floor(core.getElementMaxHitPointsById(fuelTankId))\n  system.print(fuelTankType..\"........\"..maxHP)\n  return fuelTankSpecsByMaxHP[fuelTankType]['_' .. normalizeHp(fuelTankType,maxHP)]\nend\n\nfunction getFuelTankLiters(fuelTankId)\n  local fuelTankSpecs = fuelTanks[fuelTankId]\n  local massTotal = core.getElementMassById(fuelTankId)\n  local massContents = massTotal - fuelTankSpecs.baseWeight\n  return massContents\nend\n--vanillaMaxVolume = vanillaMaxVolume - (vanillaMaxVolume * ContainerOptimization * 0.05)\nfunction getFuelTankLevel(fuelTankId)\n  local fuelTankSpecs = fuelTanks[fuelTankId]\n  local adjustedMaxMass = fuelTankSpecs.maxWeight()\n  return getFuelTankLiters(fuelTankId) / adjustedMaxMass\nend\n\nfunction getFuelTime(fuelTankId)\n  local fuelTankSpecs = fuelTanks[fuelTankId]\n  local lastUpdate = FuelTime[fuelTankId] or system.getArkTime()\n  local deltaTime = math.max(system.getArkTime() - lastUpdate, 0.001)\n  local massTotal = core.getElementMassById(fuelTankId)\n  local minMass = fuelTankSpecs.baseWeight\n  local fuelUsed = FuelMass[fuelTankId](massTotal)\n  local fuelTime = (deltaTime / fuelUsed) * (massTotal - minMass)\n  local fuelTimeFormatted = disp_time(fuelTime)\n  FuelTime[fuelTankId] = system.getArkTime()\n  return fuelTimeFormatted\n\nend\n\nfunction getFuelTanks()\n  \n\n  local elementIds = core.getElementIdList()\n  for k, elementId in pairs(elementIds) do\n    local elementType = core.getElementDisplayNameById(elementId)\n    -- Fuel tank configuration routine\n    if elementType == \"Atmospheric Fuel Tank\" then\n      --system.print(elementType..\"_\"..elementId)\n      local tank = getFuelTankSpecs(\"atmo\", elementId)\n      fuelTanks[elementId] = tank\n      FuelMass[elementId] = fuelUsed(2)\n    elseif elementType == \"Space Fuel Tank\" then\n      fuelTanks[elementId] = getFuelTankSpecs(\"space\", elementId)\n      FuelMass[elementId] = fuelUsed(2)\n    elseif elementType == \"Rocket Fuel Tank\" then\n      fuelTanks[elementId] = getFuelTankSpecs(\"rocket\", elementId)\n      FuelMass[elementId] = fuelUsed(2)\n    end\n  end\n\n  for _, v in ipairs(fuelTankSpecsByMaxHP) do\n    --system.print(\"Fuel Tank: \"..v)\n    for k,t in ipairs(v) do\n      for x,y in pairs(t) do\n        --system.print(\"Capacity: \"..y.capacity())\n      end\n    end\n  end\nend\n\ngetFuelTanks()\n",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "10"
    },
    {
      "code": "--@class TagManagerMin\nfunction TagManager(a)self={}local b={}local c=\"\"local function d(e,f)if e==''then return false end;local g,h=0,{}for i,j in function()return string.find(f,e,g,true)end do table.insert(h,string.sub(f,g,i-1))g=j+1 end;table.insert(h,string.sub(f,g))return h end;function self.tagsToString()if#b==0 then c=\"all\"else c=table.concat(b,\",\")end end;function self.Remove(k)if type(k)~=\"string\"then error(\"[TagManager] Unable to remove a tag - Not a string\")end;for l,m in pairs(b)do if k==m then table.remove(b,l)end end;self.tagsToString()end;function self.Add(k)if type(k)~=\"string\"then error(\"[TagManager] Unable to add a tag - Not a string\")end;for l,m in pairs(b)do if k==m then return end end;table.insert(b,k)self.tagsToString()end;if a~=nil and type(a)==\"string\"then for l,m in pairs(d(\",\",a))do self.Add(m)end else self.Add(\"all\")end;setmetatable(self,{__tostring=function(self)return c end})return self end",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "11"
    },
    {
      "code": "--@class KeybindControllerMin\nfunction Keybind(a)local self={}self.Key=a;local b={}function self.Add(c,d)if type(c)~=\"function\"then error(\"[Keybind] Unable to add callback - not a function\")end;table.insert(b,{Function=c,Name=d})end;function self.Remove(c)if type(c)~=\"function\"then error(\"[Keybind] Unable to remove callback - not a function\")end;local e={}for f,g in pairs(b)do e[g.Function]=f end;for f,g in pairs(e)do if f==c then b[g]=nil end end end;function self.GetNames()local h={}for f,g in pairs(b)do if g.Name then table.insert(h,g.Name)end end;return h end;function self.Call()for f,g in pairs(b)do g.Function(self.Key)end end;return self end;function KeybindController()local self={}local i={\"forward\",\"backward\",\"left\",\"right\",\"yawleft\",\"yawright\",\"up\",\"down\",\"gear\",\"light\",\"landing\",\"brake\",\"option1\",\"option2\",\"option3\",\"option4\",\"option5\",\"option6\",\"option7\",\"option8\",\"option9\",\"stopengines\",\"speedup\",\"speeddown\",\"antigravity\",\"booster\",\"lshift\",\"lalt\",\"lalt\",\"strafeleft\",\"straferight\"}self.keyUp={}self.keyDown={}self.keyLoop={}function self.Call(j,type)if type==\"up\"then if self.keyUp[j]then self.keyUp[j].Call(j)end elseif type==\"down\"then if self.keyDown[j]then self.keyDown[j].Call(j)end else if self.keyLoop[j]then self.keyDown[j].Call(j)end;system.print(j)end end;function self.GetNamedKeybinds()local h={}for f,g in pairs(self.keyUp)do local k=g.GetNames()if#k>0 then for l=1,#k do table.insert(h,{Key=g.Key,Name=k[l]})end end end;for f,g in pairs(self.keyDown)do local k=g.GetNames()if#k>0 then for l=1,#k do table.insert(h,{Key=g.Key,Name=k[l]})end end end;for f,g in pairs(self.keyLoop)do local k=g.GetNames()if#k>0 then for l=1,#k do table.insert(h,{Key=g.Key,Name=k[l]})end end end;table.sort(h,function(m,n)return m.Key<n.Key end)return h end;self.Init=function()end;local function o()for l=1,#i do self.keyUp[i[l]]=Keybind(i[l])self.keyDown[i[l]]=Keybind(i[l])self.keyLoop[i[l]]=Keybind(i[l])end end;o()return self end;keybindPresets={}",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "12"
    },
    {
      "code": "--@class IOScheduler\n\n--[[\nCustom IO scheduler to deal with limited data packet size\nand tick rate of screen send/receive. IOScheduler.defaultData\nwill send as fast as possible, while IOScheduler.queueData()\nwill interrupt default send and to send queued data.\n--]]\n\nIOScheduler = (function()\n    local self = {}\n\n    self.defaultData = nil\n    self.currentTask = nil\n    self.taskQueue = {}\n    function self.queueData(data)\n         table.insert(self.taskQueue, data)\n    end\n    --Send queued data to screen\n    function self.send(T)\n        output = screen.getScriptOutput()\n        screen.clearScriptOutput()\n        if output ~= \"ack\" then\n            if output ~= \"\" then\n                handleOutput.Read(output)\n            end\n            coroutine.yield()\n            self.send(T)\n        else\n            screen.setScriptInput(serialize(T))\n        end\n    end\n    --Queue data to send or send self.defaultData\n    function self.runQueue()\n        if #self.taskQueue == 0 then\n            --Send default table\n            if self.defaultData ~= nil then\n                   self.currentTask = coroutine.create(function()\n                       self.send(self.defaultData)\n                   end)\n            coroutine.resume(self.currentTask)\n            end\n        else\n            --Iterate over self.taskQueue and send each to screen\n            self.currentTask = coroutine.create(function()\n                for i=1, #self.taskQueue do\n                    local data = self.taskQueue[i]\n                    if type(data) == \"table\" then\n                        self.send(data)\n                    end\n                    table.remove(self.taskQueue,i)\n                end\n            end)\n            coroutine.resume(self.currentTask)\n        end\n    end\n\n    --Add to system.update()\n    function self.update()\n        if self.currentTask then\n            if coroutine.status(self.currentTask) ~= \"dead\" then\n                coroutine.resume(self.currentTask)\n            else\n                self.runQueue()\n            end\n        else\n            self.runQueue()\n        end\n    end\n\n    return self\nend)()\n\nHandleOutput = (function()\n    local self = {}\n    function self.Read(output)\n        --system.print(\"handleOutput.Read(): \"..output)\n        if output ~= nil and output ~= \"\" then\n            if type(output) == \"string\" then\n                --system.print(output)\n                local s = deserialize(output)\n\n                if s.dataType == \"config\" then\n                    config = s\n                    stats.data.target = config.targetAlt\n                    self.Execute()\n                elseif s.updateReq then\n                    ioScheduler.queueData(config)\n                else\n                    system.print(tostring(s))\n                end\n            end\n\n        end\n    end\n\n    function self.Execute()\n        ship.baseAltitude = helios:closestBody(ship.baseLoc):getAltitude(ship.baseLoc)\n\n        ship.altitudeHold = config.targetAlt\n\n        if config.estop then\n\n            ship.altitudeHold = 0\n            config.targetAlt = 0\n            ship.verticalLock = false\n            ship.elevatorActive = false\n            ship.brake = true\n            ship.stateMessage = \"EMERGENCY STOP\"\n            system.print(ship.stateMessage)\n            ioScheduler.queueData(config)\n        else\n            ship.brake = false\n        end\n        if ship.altitudeHold ~= 0 then\n            ship.elevatorActive = true\n            system.print(\"Alt diff: \"..(config.targetAlt - ship.baseAltitude))\n            ship.targetDestination = moveWaypointZ(ship.baseLoc, config.targetAlt - ship.baseAltitude)\n        end\n        if config.setBaseReq then\n            setBase()\n            config.setBaseReq = false\n            ioScheduler.queueData(config)\n        end\n        --if config.updateReq then\n        --    config.updateReq = false\n        --    ioScheduler.queue(config)\n        --end\n        manualControlSwitch()\n    end\n\n    return self\nend)()\n\nioScheduler = IOScheduler\nhandleOutput = HandleOutput",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "13"
    },
    {
      "code": "--@class STEC\n--[[\n    Shadow Templar Engine Control\n    Version: 1.17\n\n    Setup:\n        - Put this file in system.start\n        - Replace system.flush with: engines.apply()\n        - Replace all controls with the appropriate STEC equivalent:\n            - ship.direction.x - left/right\n            - ship.direction.y - forward/back\n            - ship.direction.z - forward/back\n            - ship.rotation.x - pitch\n            - ship.rotation.y - roll\n            - ship.rotation.z - yaw\n        - See comments for additional functionality\n]]\nlocal atlas = require('atlas')\nplanetaryReference = PlanetRef()\ngalaxyReference = planetaryReference(atlas)\nhelios = galaxyReference[0]\nkinematics = Kinematics()\nlocal jdecode = json.decode\nlocal maxBrake = jdecode(unit.getWidgetData()).maxBrake\n\nfunction STEC(core, control, Cd)\n    local self = {}\n    self.core = core\n    self.construct = construct\n    self.control = control\n    self.nearestPlanet = helios:closestBody(construct.getWorldPosition())\n    self.world = {\n        up = vec3(construct.getWorldOrientationUp()),\n        down = -vec3(construct.getWorldOrientationUp()),\n        left = -vec3(construct.getWorldOrientationRight()),\n        right = vec3(construct.getWorldOrientationRight()),\n        forward = vec3(construct.getWorldOrientationForward()),\n        back = -vec3(construct.getWorldOrientationForward()),\n        velocity = vec3(construct.getWorldVelocity()),\n        acceleration = vec3(construct.getWorldAcceleration()),\n        position = vec3(construct.getWorldPosition()),\n        gravity = vec3(core.getWorldGravity()),\n        vertical = vec3(core.getWorldVertical()),\n        atmosphericDensity = control.getAtmosphereDensity(),\n        nearPlanet = unit.getClosestPlanetInfluence() > 0,\n        atlasAltitude = self.nearestPlanet:getAltitude(construct.getWorldPosition())\n    }\n    self.target = {\n        prograde = function() return self.world.velocity:normalize() end,\n        retrograde = function() return -self.world.velocity:normalize() end,\n        radial = function() return self.world.gravity:normalize() end,\n        antiradial = function() return -self.world.gravity:normalize() end,\n        normal = function() return self.world.velocity:normalize():cross(self.world.gravity:normalize()):normalize() end,\n        antinormal = function() return self.world.velocity:normalize():cross(-self.world.gravity:normalize()):normalize() end,\n    }\n    \n    self.rot = vec3(0,0,0)\n    self.deviationRot = vec3(0,0,0)\n    -- Construct id\n    self.id = construct.getId()\n    -- Control Mode - Travel (0) or Cruise (1)\n    self.controlMode = unit.getControlMode()\n    -- Alternate Control Mode for remote control\n    self.alternateCM = false\n    -- Active engine tags\n    self.tags = TagManager(\"all,brake\")\n    -- Target vector to face if non-0. Can take in a vec3 or function which returns a vec3\n    self.targetDestination = nil\n    self.targetdestination = nil\n    self.baseLoc = vec3(0,0,0)\n    self.baseAltitude = 0\n    self.verticalLock = false\n    self.lockVector = vec3(0,0,0)\n    self.lockPos = vec3(0,0,0)\n    self.altHoldPreset1 = 0\n    self.altHoldPreset2 = 0\n    self.altHoldPreset3 = 0\n    self.altHoldPreset4 = 0\n    self.deviation = 0\n    self.deviationVec = vec3(0,0,0)\n    self.stateMessage = \"\"\n    self.pocket = false\n    self.autoShutdown = false\n    self.dockingClamps = false\n    self.elevatorDestination = vec3(0,0,0)\n    self.IDIntensity = 5\n    self.deviationThreshold = 0.05\n    self.playerId = player.getId()\n    self.targetVectorVertical = nil\n    self.breadCrumbDist = 1000\n    self.deviated = false\n    self.breadCrumbs = {}\n    self.hoverHeight = 10\n    -- Whether the target vector should unlock automatically if the ship is rotated by the pilot\n    self.targetVectorAutoUnlock = true\n    -- Current altitude\n    self.altitude = 0\n    -- Current mass of the vessel, in kilograms\n    self.mass = self.construct.getMass()\n    -- Amount of thrust to apply in world space, in Newton. Stacks with {{direction}}\n    self.thrust = vec3(0, 0, 0)\n    -- Amount of thrust to apply in local space, in percentage of fMax 0-1\n    self.direction = vec3(0, 0, 0)\n    -- Amount of rotation to apply in local space\n    self.rotation = vec3(0, 0, 0)\n    -- Speed scale factor for rotations\n    self.rotationSpeed = 2\n    -- Minimum rotation speed for auto-scale\n    self.rotationSpeedzMin = 0.01\n    -- Rotation Speed on x axis\n    self.rotationSpeedz = 0.01\n    -- Max rotation speed for auto-scale\n    self.maxRotationSpeedz = 3\n    -- Auto-scale rotation Setup\n    self.rotationStep = 0.03\n    -- Breaking speed multiplier\n    self.brakingFactor = 10\n    -- Amount of angular thrust to apply, in world space\n    self.angularThrust = vec3(0, 0, 0)\n    -- Whether or not the vessel should attempt to cancel out its current velocity in directions that are not being accelerated towards\n    self.inertialDampening = false\n    -- Desired state of intertialDampening\n    self.inertialDampeningDesired = false\n    -- Whether or not the vessel should attempt to completely cancel out its current velocity\n    self.brake = false\n    -- Whether or not the vessel should attempt to counter gravity influence\n    self.counterGravity = true\n    -- Whether or not the vessel should attempt to face perpendicular to the gravity vector\n    self.followGravity = false\n    -- Aggressiveness of the gravity follow adjustment\n    self.gravityFollowSpeed = 6\n    -- Speed (in km/h) in which to limit the velocity of the ship\n    self.speedLimiter = 2000\n    -- Variable speed limit based on delta distance in altitude hold mode\n    self.variableSpeedLimit = 2000\n    -- Toggle speed limiter on/off\n    self.speedLimiterToggle = true\n    -- Vertical Speed Limit (Atmo)\n    self.verticalSpeedLimitAtmo = 750\n    -- Vertical Speed Limit (Space)\n    self.verticalSpeedLimitSpace = 2000\n    -- Final approach speed\n    self.approachSpeed = 200\n    -- Amount of throttle to apply. 0-1 range\n    self.throttle = 1\n    -- Maximum thrust which the vessel is capable of producing\n    self.fMax = 0\n    self.vMax = 0\n    self.hMax = 0\n    -- Toggle altitude hold on/off\n    self.elevatorActive = false\n    -- Altitude which the vessel should attempt to hold\n    self.altitudeHold = 0\n    -- Atmosphere density Threshold\n    self.atmosphereThreshold = 0\n    -- Speed which the vessel should attempt to maintain\n    self.cruiseSpeed = 0\n    -- Whether or not to ignore throttle for vertical thrust calculations\n    self.ignoreVerticalThrottle = false\n    -- Local velocity\n    self.localVelocity = vec3(construct.getVelocity())\n    self.brakeDistance = 0\n    self.accelTime = nil\n    -- Roll Degrees\n    self.rollDegrees = self.world.vertical:angle_between(self.world.left) / math.pi * 180 - 90\n    self.viewY = 0\n    self.viewX = 0\n    if self.world.vertical:dot(self.world.up) > 0 then self.rollDegrees = 180 - self.rollDegrees end\n    -- Pitch\n    self.pitchRatio = self.world.vertical:angle_between(self.world.forward) / math.pi - 0.5\n    --Vertical Cruise Toggle (for elevator stuff)\n    self.verticalCruise = false\n    --Vertical Cruise Speed (for elevator stuff)\n    self.verticalCruiseSpeed = 0\n    self.priorityTags1 = \"brake,airfoil,torque,vertical,lateral,longitudinal\"\n    self.priorityTags2 = \"atmospheric_engine,space_engine\"\n    self.priorityTags3 = \"\"\n\t\n    local lastUpdate = system.getArkTime()\n\n    function self.updateWorld()\n        self.world = {\n            up = vec3(construct.getWorldOrientationUp()),\n            down = -vec3(construct.getWorldOrientationUp()),\n            left = -vec3(construct.getWorldOrientationRight()),\n            right = vec3(construct.getWorldOrientationRight()),\n            forward = vec3(construct.getWorldOrientationForward()),\n            back = -vec3(construct.getWorldOrientationForward()),\n            velocity = vec3(construct.getWorldVelocity()),\n            acceleration = vec3(construct.getWorldAcceleration()),\n            position = vec3(construct.getWorldPosition()),\n            gravity = vec3(core.getWorldGravity()),\n            vertical = vec3(core.getWorldVertical()),\n            atmosphericDensity = control.getAtmosphereDensity(),\n            nearPlanet = unit.getClosestPlanetInfluence() > 0,\n            atlasAltitude = self.nearestPlanet:getAltitude(construct.getWorldPosition())\n        }\n        self.nearestPlanet = helios:closestBody(construct.getWorldPosition())\n\t   -- Roll Degrees\n        self.rollDegrees = self.world.vertical:angle_between(self.world.left) / math.pi * 180 - 90\n        if self.world.vertical:dot(self.world.up) > 0 then self.rollDegrees = 180 - self.rollDegrees end\n        -- Pitch\n        self.pitchRatio = self.world.vertical:angle_between(self.world.forward) / math.pi - 0.5\n        \n        self.AngularVelocity = vec3(construct.getWorldAngularVelocity())\n        self.AngularAcceleration = vec3(construct.getWorldAngularAcceleration())\n        self.AngularAirFriction = vec3(construct.getMaxThrustAlongAxis())\n\n\t    self.airFriction = vec3(construct.getWorldAirFrictionAcceleration())\n        \n        local atmoRadius = helios:closestBody(construct.getWorldPosition()).atmosphereRadius\n        local planetRadius = helios:closestBody(construct.getWorldPosition()).radius\n\n        self.atmosphereThreshold = atmoRadius - planetRadius\n        --system.print(\"Planet Radius: \"..helios:closestBody(construct.getWorldPosition()).radius)\n        --system.print(\"atmosphereThreshold = \" .. self.atmosphereThreshold)\n\t    self.airFriction = vec3(construct.getWorldAirFrictionAcceleration())\n        \n        self.mass = self.construct.getMass()\n        --self.altitude = self.core.getAltitude()\n        self.altitude = helios:closestBody(construct.getWorldPosition()):getAltitude(construct.getWorldPosition())\n        self.localVelocity = vec3(construct.getVelocity())\n        self.maxBrake = jdecode(unit.getWidgetData()).maxBrake\n        local fMax = construct.getMaxThrustAlongAxis(\"all\", {vec3(0,1,0):unpack()})\n        local vMax = construct.getMaxThrustAlongAxis(\"all\", {vec3(0,0,1):unpack()})\n        --system.print(\"vMax[1]: \"..round2(vMax[1],0))\n        --system.print(\"vMax[2]: \"..round2(vMax[2],0))\n        --system.print(\"vMax[3]: \"..round2(vMax[3],0))\n        --system.print(\"vMax[4]: \"..round2(vMax[4],0))\n        local hMax = construct.getMaxThrustAlongAxis(\"all\", {vec3(1,0,0):unpack()})\n        if self.world.atmosphericDensity > 0.1 then\n            self.fMax = math.max(fMax[1], -fMax[2])\n        else\n            self.fMax = math.max(fMax[3], -fMax[4])\n        end\n        if self.world.atmosphericDensity > 0.1 then\n            self.vMax = math.max(vMax[1], -vMax[2])\n        else\n            self.vMax = math.min(vMax[3], -vMax[4])\n        end\n        if self.world.atmosphericDensity > 0.1 then\n            self.hMax = math.max(hMax[1], -hMax[2])\n        else\n            self.hMax = math.max(hMax[3], -hMax[4])\n        end\n        --system.print(self.world.velocity:dot(-self.world.gravity:normalize()))\n        local gravN = self.mass * core.getGravityIntensity()\n        local correctedThrust = self.vMax\n        local correctedBrake = self.maxBrake\n        local sign = 1\n\n        if self.maxBrake ~= nil and core.getGravityIntensity() >= 1 then\n            if self.world.velocity:dot(-self.world.gravity:normalize()) < 1 then\n                sign = -1\n            end\n            gravN = gravN * sign\n            correctedThrust = self.vMax + gravN\n            correctedBrake = self.maxBrake + gravN\n        end\n        self.brakeDistance, self.accelTime = kinematics.computeDistanceAndTime(self.world.velocity:len(), 0, self.mass, correctedThrust,20,correctedBrake)\n\n\n    end\n\n    function self.calculateAccelerationForce(acceleration, time)\n        return self.mass * (acceleration / time)\n    end\n\n    function clamp(n, min, max)\n        return math.min(max, math.max(n, min))\n    end\n    function round(num, numDecimalPlaces)\n        local mult = 10^(numDecimalPlaces or 0)\n        return math.floor(num * mult + 0.5) / mult\n    end\n    function self.throttleUp()\n        self.throttle = clamp(self.throttle + 0.05, 0, 1)\n    end\n\n    function self.throttleDown()\n        self.throttle = clamp(self.throttle - 0.05, 0, 1)\n    end\n\n    function moveWaypointZ(vector, altitude)\n        return (vector - (ship.nearestPlanet:getGravity(vector)):normalize() * (altitude))\n    end\n\n    function self.worldToLocal(vector)\n        return vec3(\n            library.systemResolution3(\n                {self.world.right:unpack()},\n                {self.world.forward:unpack()},\n                {self.world.up:unpack()},\n                {vector:unpack()}\n            )\n        )\n    end\n\n    function self.localToRelative(pos, up, right, forward)\n        -- this is horrible, can optimize?\n        local rightX, rightY, rightZ = right:unpack()\n        local forwardX, forwardY, forwardZ = forward:unpack()\n        local upX, upY, upZ = up:unpack()\n        local rfuX, rfuY, rfuZ = pos:unpack()\n        local relX = rfuX * rightX + rfuY * forwardX + rfuZ * upX\n        local relY = rfuX * rightY + rfuY * forwardY + rfuZ * upY\n        local relZ = rfuX * rightZ + rfuY * forwardZ + rfuZ * upZ\n        return vec3(relX, relY, relZ)\n    end\n\n    function MsToKmh(ms)\n        return ms * 3.6\n    end\n    function KmhToMs(kmh)\n        return kmh / 3.6\n    end\n    \n    function self.apply()\n        local deltaTime = math.max(system.getArkTime() - lastUpdate, 0.001) --If delta is below 0.001 then something went wrong in game engine.\n        self.updateWorld()\n        local tmp = self.thrust\n        local atmp = self.angularThrust\n        local gravityCorrection = false\n        local fMax = construct.getMaxThrustAlongAxis(\"all\", {vec3(0,1,0):unpack()})\n        local vMaxUp = construct.getMaxThrustAlongAxis(\"all\", {vec3(0,0,1):unpack()})\n        local vMaxDown = construct.getMaxThrustAlongAxis(\"all\", {vec3(0,0,-1):unpack()})\n        local hMax = construct.getMaxThrustAlongAxis(\"all\", {vec3(1,0,0):unpack()})\n\n        -- Elevator stuff\n\n        if lockVerticalToBase then\n            --self.baseLoc\n            self.altitude = helios:closestBody(self.baseLoc):getAltitude(construct.getWorldPosition())\n            self.nearestPlanet = helios:closestBody(self.baseLoc)\n            atmoRadius = helios:closestBody(self.baseLoc).atmosphereRadius\n            planetRadius = helios:closestBody(self.baseLoc).radius\n\n        end\n        if not self.elevatorActive then self.inertialDampening = self.inertialDampeningDesired end\n        \n        if self.direction.x ~= 0 then\n            local dot  = (1 - self.world.up:dot(-self.world.gravity:normalize())) * (self.mass * 0.000095) -- Magic number is magic\n            local gravCorrection = -self.world.vertical * dot\n\n            if self.direction.x < 0 and math.abs(round2(hMax[2],0)) < 500 then\n                gravityCorrection = true\n                --tmp = tmp + ((((self.world.right * self.direction.x) + gravCorrection):normalize() * self.mass * self.fMax) * self.throttle)\n                tmp = tmp + ((((self.world.right * self.direction.x) + gravCorrection):normalize() * self.fMax) * self.throttle)\n            elseif self.direction.x > 0 and math.abs(round2(hMax[1],0)) < 500 then\n                gravityCorrection = true\n                tmp = tmp + ((((self.world.right * self.direction.x) + gravCorrection):normalize() * self.fMax) * self.throttle)\n            else\n                tmp = tmp + (((self.world.right * self.direction.x) * self.fMax) * self.throttle) -- OG code\n            end\n        end\n        \n        if self.direction.y ~= 0 then\n            \n            --tmp = tmp + (((self.world.forward * self.direction.y) * self.fMax) * self.throttle)\n            --tmp = tmp + (((self.world.gravity:normalize():cross(-self.world.right) * self.direction.y) * self.fMax) * self.throttle)\n            local dot  = (1 - self.world.up:dot(-self.world.gravity:normalize())) * (self.mass * 0.000095)\n            local gravCorrection = -self.world.vertical * dot\n            --system.print(math.abs(round2(fMax[2],0)))\n            if self.direction.y < 0 and math.abs(round2(fMax[2],0)) == 0 then\n                gravityCorrection = true\n                tmp = tmp + ((((self.world.forward * self.direction.y) + gravCorrection):normalize() * self.fMax) * self.throttle)\n            else\n                tmp = tmp + (((self.world.forward * self.direction.y) * self.fMax) * self.throttle)\n            end\n            \n        end\n        if self.direction.z ~= 0 then\n            local a = ((self.world.up * self.direction.z) * self.fMax)\n            if not self.ignoreVerticalThrottle then a = a * self.throttle end\n            tmp = tmp + a\n        end\n        if self.rotation.x ~= 0 then\n            atmp = atmp + ((self.world.forward:cross(self.world.up) * self.rotation.x) * self.rotationSpeed)\n            if self.targetVectorAutoUnlock then\n                self.targetVector = nil\n            end\n        end\n        if self.rotation.y ~= 0 then\n            atmp = atmp + ((self.world.up:cross(self.world.right) * self.rotation.y) * self.rotationSpeed)\n        end\n        if self.rotation.z ~= 0 then\n            if self.rotationSpeedz <= self.maxRotationSpeedz then self.rotationSpeedz = self.rotationSpeedz + self.rotationStep end\n            --system.print(\"Rotation Speed: \"..self.rotationSpeedz)\n            atmp = atmp + ((self.world.forward:cross(self.world.right) * self.rotation.z) * clamp(self.rotationSpeedz, 0.01, self.maxRotationSpeedz))\n            if self.targetVectorAutoUnlock then\n                self.targetVector = nil\n            end\n        end\n        if self.followGravity and self.rotation.x == 0 then\n            \n          --system.print(tostring(self.direction))\n\t\t    local current = self.localVelocity:len() * self.mass\n            local scale = nil\n            --if ship.localVelocity:len() > 10 then\n            --    scale = self.gravityFollowSpeed * math.min(math.max(current / self.fMax, 0.1), 1) * 10\n            --else\n            --    scale = self.gravityFollowSpeed\n            --end\n            local gFollow = (self.world.up:cross(-self.nearestPlanet:getGravity(construct.getWorldPosition())))\n            if lockVerticalToBase then gFollow = (self.world.up:cross(-self.nearestPlanet:getGravity(self.baseLoc))) end\n            local scale = 1\n            if self.pocket then\n                if self.direction.x < 0  then\n                    scale = 0.25\n                    gFollow = gFollow + ship.world.right:cross(-self.nearestPlanet:getGravity(construct.getWorldPosition()) * 0.25)\n                elseif self.direction.x > 0  then\n                    scale = 0.25\n                    gFollow = gFollow - ship.world.right:cross(-self.nearestPlanet:getGravity(construct.getWorldPosition()) * 0.25)\n                elseif self.direction.y < 0  then\n                    gFollow = gFollow + ship.world.forward:cross(-self.nearestPlanet:getGravity(construct.getWorldPosition()) * 0.25)\n                end\n            end\n            gFollow = gFollow * scale\n            atmp = atmp + gFollow\n        end\n        \n        self.deviationVec = (moveWaypointZ(self.baseLoc, self.altitude - self.baseAltitude) - self.world.position)\n        self.deviationRot = self.world.forward:cross(self.rot)\n        self.deviation = self.deviationVec:len()\n\n        if self.elevatorActive then\n            if not self.inertialDampening then self.inertialDampening = true end\n            if not self.counterGravity then self.counterGravity = true end\n            self.targetVector = self.rot\n            if self.world.velocity:len() > (2000 / 3.6) then deviation = 0 end\n            \n            local deltaAltitude =  self.altitudeHold - self.altitude\n            local brakeBuffer = 1000\n            \n            local speed = 0\n            --local self.breadCrumbDist = 500\n            local distance = (self.world.position - self.targetDestination):len()\n            \n            local realDistance = helios:closestBody(self.baseLoc):getAltitude(self.targetDestination) - self.altitude\n            local destination = vec3(0,0,0)\n            local verticalSpeedLimit\n            \n            \n            local dampen = 1\n\n            --if self.world.velocity:len() < 55.555 then\n                \n            --end\n            \n            if self.altitude <= (self.atmosphereThreshold + self.brakeDistance) or self.altitude <= self.brakeDistance then \n                verticalSpeedLimit = self.verticalSpeedLimitAtmo\n            else \n                verticalSpeedLimit = self.verticalSpeedLimitSpace\n            end\n            if  (self.brakeDistance + brakeBuffer) >= math.abs(deltaAltitude) then\n                verticalSpeedLimit = self.approachSpeed\n            end\n            \n            --system.print(\"self.deviation: \"..self.deviation)\n            \n            \n            local deviationThreshold = self.deviationThreshold\n            if self.deviated or self.world.velocity:len() < 1 then deviationThreshold = 0.05 end\n            --system.print(\"Deviation threshold: \"..deviationThreshold)\n            if self.deviation > (deviationThreshold + self.world.velocity:len() * 10^-2) then\n            --if self.deviation > deviationThreshold then\n                destination = moveWaypointZ(self.baseLoc, (self.altitude - self.baseAltitude))\n                self.deviated = true\n                speed = self.deviation * self.IDIntensity\n                self.stateMessage = \"Correcting Deviation\"\n            else\n                self.deviated = false\n                destination = self.targetDestination\n            end\n\n            if math.abs(deltaAltitude) > self.brakeDistance and math.abs(deltaAltitude) > 500 and not self.deviated then\n                self.stateMessage = \"Traveling\"\n                speed = round2((clamp(deltaAltitude, -verticalSpeedLimit, verticalSpeedLimit)), 1)\n            elseif not self.deviated then\n                self.stateMessage = \"Final approach\"\n                speed = self.approachSpeed\n                if self.brakeDistance * 1.5 >= math.abs(distance) then speed = 5 end\n            end\n            --system.print(\"realDistance: \"..realDistance)\n            local breadCrumb\n            --local breadCrumbDist = utils.clamp(math.abs(self.world.velocity:len()),10,self.breadCrumbDist - (self.deviation * 100))\n\n            --system.print(breadCrumbDist)\n            if realDistance > self.breadCrumbDist and not self.deviated then\n                breadCrumb = moveWaypointZ(self.baseLoc, (self.altitude - self.baseAltitude) + self.breadCrumbDist)\n                destination = breadCrumb\n                local waypointString = ship.nearestPlanet:convertToMapPosition(destination)\n                system.setWaypoint(waypointString,false)\n\t\t\t    --system.print(tostring(waypointString))\n            elseif realDistance < -self.breadCrumbDist and not self.deviated then\n                breadCrumb = moveWaypointZ(self.baseLoc, (self.altitude - self.baseAltitude) - self.breadCrumbDist)\n                destination = breadCrumb\n                local waypointString = ship.nearestPlanet:convertToMapPosition(destination)\n                system.setWaypoint(waypointString,false)\n\t\t\t    --system.print(tostring(waypointString))\n            end\n            \n            self.elevatorDestination = (self.world.position - destination):normalize()\n            --system.print(\"TEST: \"..round2((distance * distance),4))\n\n            tmp = tmp - self.elevatorDestination * self.mass * utils.clamp(distance * 3.6,0.3,((math.abs(speed)/3.6) * self.IDIntensity))\n            --if breadCrumb ~= nil then system.print(\"Breadcrumb distance: \"..(self.world.position - breadCrumb):len()) end\n            if distance < 0.01 and not manualControl then\n                self.elevatorActive = false self.targetVector = nil \n                self.stateMessage = \"Idle\"\n                self.dockingClamps = true\n            elseif distance < 2 and self.world.velocity:len() == 0 and not manualControl then\n                self.elevatorActive = false self.targetVector = nil\n                self.stateMessage = \"Idle\"\n                self.dockingClamps = true\n            else\n                self.dockingClamps = false\n            end\n            \n\t    else\n            --self.stateMessage = \"Idle\"\n            self.destination = vec3(0,0,0)\n        end\n        if self.inertialDampening then\n            local currentShipMomentum = self.localVelocity\n            local delta = vec3(0,0,0)\n            local moveDirection = self.direction or vec3(0,0,0)\n\n            if moveDirection.x == 0 then delta.x = currentShipMomentum.x end\n            if moveDirection.y == 0 then delta.y = currentShipMomentum.y end\n            if moveDirection.z == 0 then delta.z = currentShipMomentum.z end\n\n            delta = self.localToRelative(delta, self.world.up, self.world.right, self.world.forward)\n            --system.print(tostring(delta))\n            tmp = tmp - (delta * (self.mass * self.IDIntensity))\n\n        end\n\n        if self.brake then\n            local velocityLen = self.world.velocity:len()\n            tmp =\n                -self.world.velocity * self.mass *\n                math.max(self.brakingFactor * math.max(1, velocityLen * 0.5), velocityLen * velocityLen)\n        end\n        if self.targetVector ~= nil then\n            local vec = vec3(self.world.forward.x, self.world.forward.y, self.world.forward.z)\n            if type(self.targetVector) == \"function\" then\n                vec = self.targetVector()\n            elseif type(self.targetVector) == \"table\" then\n                vec = self.targetVector\n            end\n            atmp = atmp + (self.world.forward:cross(vec) * (self.rotationSpeed / 4))  - ((self.AngularVelocity * 2) - (self.AngularAirFriction * 2))\n        end\n\n        if self.targetVectorVertical ~= nil then\n            local vec = vec3(self.world.up.x, self.world.up.y, self.world.up.z)\n            if type(self.targetVector) == \"function\" then\n                vec = self.targetVector()\n            elseif type(self.targetVector) == \"table\" then\n                vec = self.targetVector\n            end\n            if (self.world.up - self.targetVectorVertical):len() < 0 then\n                atmp = atmp + (-self.world.up:cross(vec) * (self.rotationSpeed / 4))  - ((self.AngularVelocity * 2) - (self.AngularAirFriction * 2))\n            else\n                atmp = atmp + (self.world.up:cross(vec) * (self.rotationSpeed / 4))  - ((self.AngularVelocity * 2) - (self.AngularAirFriction * 2))\n            end\n            \n        end\n        \n        -- must be applied last\n        if self.counterGravity then\n            --tmp = tmp - self.nearestPlanet:getGravity(construct.getWorldPosition()) * self.mass\n            tmp = tmp - self.world.gravity * self.mass\n        end\n\n        if self.verticalLock then\n            local localPos = (self.world.position + self.world.up) - self.lockPos\n            local intersectionPos = self.lockVector * self.lockVector:dot(localPos)\n            local intersectionVec = intersectionPos - localPos\n            local thrustForce = intersectionVec * (self.mass * 0.3)-- * deltaTime\n            --system.print(\"thrustForce: \" .. tostring(thrustForce))\n            tmp = tmp + thrustForce * self.mass\n         end\n\n        atmp = atmp - ((self.AngularVelocity * 2) - (self.AngularAirFriction * 2))\n        tmp = tmp / self.mass\n\n        if self.controlMode ~= unit.getControlMode() then\n            self.controlMode = unit.getControlMode()\n            if unit.getControlMode() == 0 then self.alternateCM = false end\n            if unit.getControlMode() == 1 then self.alternateCM = true end\n        end\n\n\n        --self.control.setEngineCommand(tostring(self.tags), {tmp:unpack()}, {atmp:unpack()})\n        self.control.setEngineCommand(\"atmospheric_engine,space_engine,airfoil,brake,torque,vertical,lateral,longitudinal\",\n                                        {tmp:unpack()}, {atmp:unpack()}, false, false,\n                                        self.priorityTags1,\n                                        self.priorityTags2,\n                                        self.priorityTags3)\n\n        atmp = vec3(0, 0, 0)\n        tmp = vec3(0, 0, 0)\n        self.elevatorDestination = vec3(0,0,0)\n        lastUpdate = system.getArkTime()\n    end\n\n    return self\nend\n\nship = STEC(core, unit)\n",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "14"
    },
    {
      "code": "--@class AR_HUDMin\n\njson=require('dkjson')quat=require('cpml/quat')vec3=require('cpml/vec3')const=require('cpml/constants')vec2=require('cpml/vec2')utils=require('cpml/utils')mat4=require(\"cpml/mat4\")mouseDeltaSum=vec2(0,0)local function a(b)if b>0 then return 1 elseif b<0 then return-1 else return 0 end end;function scaleViewBoundsY(c)local d=0;local e=1250/mouseSensitivity;local f=-(system.getScreenHeight()/2)local g=system.getScreenHeight()/2;return(c-d)/(e-d)*(g-f)+f end;function scaleViewBoundsX(h)local d=1;local e=-1;if a(forwardX.x)==-1 and a(forwardX.y)==-1 then d=-1;e=1 elseif a(forwardX.x)==1 and a(forwardX.y)==-1 then d=-1;e=1 end;local f=-(system.getScreenHeight()/2)local g=system.getScreenHeight()/2;return(h-d)/(e-d)*(g-f)+f end;function scaleViewBound(d,e,f,g,i)return(i-d)/(e-d)*(g-f)+f end;function deltaSum(j,k)local l=0;local m=0;if j.y+k.y<=0 then m=0 elseif j.y+k.y>=1250/mouseSensitivity then m=1250/mouseSensitivity else m=j.y+k.y end;return vec2(l,m)end;function updateAR()local n=vec2(system.getMouseDeltaX(),system.getMouseDeltaY())mouseDeltaSum=deltaSum(mouseDeltaSum,n)playerQ=quat(unit.getMasterPlayerRelativeOrientation())forwardX=playerQ*vec3(core.getConstructOrientationForward())ship.viewY=scaleViewBoundsY(mouseDeltaSum.y)ship.viewX=scaleViewBoundsX(forwardX.x)end\n",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "15"
    },
    {
      "code": "--@class SHUD\nvec2 = require('cpml/vec2')\nmat4 = require(\"cpml/mat4\")\nlocal json = require(\"dkjson\") -- For AGG\nlocal format = string.format\n\n\nif next(manualSwitches) ~= nil then\n    for _, sw in ipairs(manualSwitches) do\n      system.print(\"Deactivate!\")\n      sw.deactivate()\n    end\nend\n\nfunction SpeedConvert(value)\n    if not value or value == 0 then return {0,\"00\",\"km/h\"} end\n    if value > 5000 then\n        local endnum = tonumber(tostring(round2(value/55.55, 2)):match(\"%.(%d+)\"))\n        local ending = string.format(\"%02d\",endnum)\n        return {round2(value/55.55),ending,\"su/h\"}\n    end\n    local endnum = tonumber(tostring(round2(value/3.6, 2)):match(\"%.(%d+)\"))\n    local ending = string.format(\"%02d\",endnum)\n    return {round2(value*3.6),ending,\"km/h\"}\nend\n\nfunction CruiseControl(value)\n    local appliedCruise = 0\n\n    if ship.cruiseSpeed < 500 then appliedCruise = value * 10\n    elseif ship.cruiseSpeed >= 500 and ship.cruiseSpeed <= 1999 then appliedCruise = value * 50\n    elseif ship.cruiseSpeed >= 2000 and ship.cruiseSpeed <= 9999 then appliedCruise = value * 100\n    elseif ship.cruiseSpeed >= 10000 then appliedCruise = value * 1000 end\n\n    ship.cruiseSpeed = utils.clamp(ship.cruiseSpeed + appliedCruise,-29990,29990)\nend\n\nfunction getControlMode()\n    if ship.alternateCM then\n        return \"Cruise\"\n    end\n    return \"Travel\"\nend\n\naltHoldAdjustment = 0.1\naltAdjustment = 3\n\nfunction altHoldAdjustmentSetting()\n    return altHoldAdjustment * (10^altAdjustment)\nend\n\nfunction setAltHoldAdjustment()\nend\n\nfunction SHUDMenuItem(content, action, update)\n    local self = {}\n    self.Enabled = true\n    self.Active = false\n    self.Content = content\n    self.Class = \"\"\n    self.Action = action or function(system, unit, self) end\n    self.Update = update or function(system, unit, self) end\n\n    function self.Disable()\n        self.Enabled = false\n        return self\n    end\n\n    function self.Enable()\n        self.True = false\n        return self\n    end\n\n    function self.Lock()\n        SHUD.ScrollLock = true\n        self.Active = true\n        self.Class = \"locked\"\n        return self\n    end\n\n    function self.Unlock()\n        SHUD.ScrollLock = false\n        self.Active = false\n        self.Class = \"\"\n        return self\n    end\n\n    return self\nend\n\nSHUD =\n(function()\n    local self = {}\n    self.Enabled = false\n    self.FreezeUpdate = false\n    self.IntroPassed = false\n\n    self.FOV = system.getCameraHorizontalFov()\n    self.ScreenW = system.getScreenWidth()\n    self.ScreenH = system.getScreenHeight()\n    self.Resolution = vec2(self.ScreenW, self.ScreenH)\n\n    self.SvgMinX = -round((self.ScreenW / 4) / 2,0)\n    self.SvgMinY = -round((self.ScreenH / 4) / 2,0)\n    self.SvgWidth = round(self.ScreenW / 4,0)\n    self.SvgHeight = round(self.ScreenH / 4,0)\n\n    function scaleViewBounds(input)\n        local rMin = -0.5\n        local rMax = 0.5\n        local tMin = -90\n        local tMax = 90\n        return -(((input - rMin) / (rMax - rMin)) * (tMax - tMin) + tMin)\n    end\n\n    shipPitch = scaleViewBounds(ship.pitchRatio)\n\n    self.SHUDFuelHtml = \"\"\n\n    self.Markers = {}\n\n    self.MarkerBuffer = {}\n\n    function self.worldToScreen(position)\n        local P = mat4():perspective(self.FOV, self.ScreenW/self.ScreenH, 0.1, 100000)\n        local adjustedPos = ship.world.position - vec3(unit.getPlayerWorldPos())\n        local V = mat4():look_at(adjustedPos, adjustedPos + ship.world.forward, ship.world.up)\n\n        local pos = V * P * { position.x, position.y, position.z, 1 }\n\n        pos[1] = pos[1] / pos[4] * 0.5 + 0.5\n        pos[2] = pos[2] / pos[4] * 0.5 + 0.5\n\n        pos[1] = pos[1] * 100\n        pos[2] = pos[2] * 100\n\n        return vec3(pos[1], pos[2], pos[3])\n    end\n\n    local SMI = SHUDMenuItem\n    local DD = DynamicDocument\n\n    function self.UpdateMarkers()\n        self.MarkerBuffer = {}\n        for i=1,#self.Markers do\n            local m = self.Markers[i]\n            local marker = {}\n            local p = vec3(0,0,0)\n            if type(m.Position) == \"function\" then marker.pos = m.Position() p = m.Position() else marker.pos = m.Position p = m.Position end\n            marker.pos = self.worldToScreen(marker.pos)\n            marker.class = m.Class\n            marker.content = '&nbsp;'\n            if m.Name then marker.content = [[<div class=\"name\">]] .. m.Name .. [[</div>]] end\n            if m.ShowDistance then marker.content = marker.content .. [[<div class=\"distance\">]] .. round2((ship.world.position - p):len()) .. [[m</div>]] end\n            if marker.pos.z > 0 then self.MarkerBuffer[#self.MarkerBuffer + 1] = marker end\n        end\n    end\n\n    local function esc(x)\n        return (x:gsub(\"%%\", \"%%%%\"))\n    end\n\n    function self.MakeBooleanIndicator(varName)\n        local tmpl = [[<span class=\"right\">\n            <i dd-if=\"varName == true\">✓&nbsp;</i>\n            <i dd-if=\"varName == false\">✘&nbsp;</i>\n        </span>]]\n        return tmpl:gsub(\"varName\", esc(varName))\n    end\n\n    function self.MakeSliderIndicator(varName, suffix)\n        suffix = suffix or \"\"\n        local tmpl = [[<span class=\"right\">{{varName}}{{suffix}}<i>&udarr;&nbsp;</i></span>]]\n        return tmpl:gsub(\"varName\", esc(varName)):gsub(\"{{suffix}}\", esc(suffix))\n    end\n\n    function self.GenerateMenuLink(text, link)\n        return SMI(text..self.MenuIcon,  function() self.SelectMenu(link) end)\n    end\n\n    self.MenuIcon = [[<span class=\"right\"><i>&gt;&nbsp;</i></span>]]\n    self.BackButton = SMI([[<i>&lt;&nbsp;</i>&nbsp;]]..\"Back\", function() SHUD.Menu = SHUD.MenuList.prev SHUD.CurrentIndex = 1 end)\n    self.Menu = {\n            SMI(DD([[<span>Throttle<span>]]..self.MakeSliderIndicator(\"round2(ship.throttle * 100)\", \"%\")),\n                function(_, _, w) if w.Active then w.Unlock() else w.Lock() end end,\n                function(system, _ , w) ship.throttle = utils.clamp(ship.throttle + (system.getMouseWheel() * 0.05),-1,1) end),\n\n            self.GenerateMenuLink(\"Stability Assist\", \"stability\"),\n            self.GenerateMenuLink(\"Altitude Hold\", \"altHold\"),\n            self.GenerateMenuLink(\"Ship Stats\", \"shipStats\"),\n            SMI([[<i>&#9432;&nbsp;</i><span>&nbsp;Hotkeys</span>]]..self.MenuIcon, function() self.SelectMenu(\"hotkeys\") end)\n    }\n    self.MenuList = {}\n    self.MenuList.flightMode = {}\n    self.MenuList.shipStats = {\n        SMI(DD([[<span>Core ID:</span><span class=\"right\">{{ship.id}}</span>]])).Disable(),\n        SMI(DD([[<span>Mass:</span><span class=\"right\">{{round2(ship.mass/1000,2)}} Ton</span>]])).Disable(),\n        SMI(DD([[<span>FMax:</span><span class=\"right\">{{round2(ship.fMax/1000,2)}} KN</span>]])).Disable(),\n        SMI(DD([[<span>Pos X:</span><span class=\"right\">{{round2(ship.world.position.x)}}</span>]])).Disable(),\n        SMI(DD([[<span>Pos Y:</span><span class=\"right\">{{round2(ship.world.position.y)}}</span>]])).Disable(),\n        SMI(DD([[<span>Pos Z:</span><span class=\"right\">{{round2(ship.world.position.z)}}</span>]])).Disable(),\n    }\n\n    self.MenuList.stability = {\n        SMI(DD(\"<span>Gravity Suppression<span>\" .. self.MakeBooleanIndicator(\"ship.counterGravity\")), function() ship.counterGravity = not ship.counterGravity end),\n        SMI(DD(\"<span>Gravity Follow</span>\" .. self.MakeBooleanIndicator(\"ship.followGravity\")), function() ship.followGravity = not ship.followGravity end),\n        SMI(DD(\"<span>Inertial Dampening<span>\" .. self.MakeBooleanIndicator(\"ship.inertialDampening\")), function() ship.inertialDampeningDesired = not ship.inertialDampeningDesired end),\n        SMI(DD([[<span>Hover Height<span>]]..self.MakeSliderIndicator(\"ship.hoverHeight\", \"m\")),\n               function(_, _, w) if w.Active then w.Unlock() else w.Lock() end end,\n               function(system, _ , w) ship.hoverHeight = utils.clamp(ship.hoverHeight + (system.getMouseWheel()),0,35) end),\n    }\n    function self.updateTargetDest()\n        ship.targetDestination = moveWaypointZ(ship.baseLoc, utils.clamp(ship.altitudeHold + (system.getMouseWheel() * altHoldAdjustmentSetting()),0,2000000) - ship.baseAltitude)\n        ship.altitudeHold = utils.clamp(ship.altitudeHold + (system.getMouseWheel() * altHoldAdjustmentSetting()),0,2000000)\n    end\n    self.MenuList.altHold = {\n        SMI(DD(\"<span>Altitude Hold<span>\" .. self.MakeBooleanIndicator(\"ship.elevatorActive\")), function() ship.elevatorActive = not ship.elevatorActive end),\n        SMI(DD([[<span>Multiplier<span>]]..self.MakeSliderIndicator(\"round2(altHoldAdjustmentSetting(),3)\", \"\")),\n               function(_, _, w) if w.Active then w.Unlock() else w.Lock() end end,\n               function(system, _ , w) altAdjustment = utils.clamp(altAdjustment + (system.getMouseWheel()),-1,4) end),\n        SMI(DD([[<span>Alt Setpoint<span>]]..self.MakeSliderIndicator(\"round2(ship.altitudeHold,3)\", \"m\")),\n               function(_, _, w) if w.Active then w.Unlock() else w.Lock() end end,\n               function(system, _ , w) self.updateTargetDest() end),\n        SMI(DD([[<span>Preset 1:</span><span class=\"right\">]].. mToKm(ship.altHoldPreset1)..\"</span>\"), function() ship.altitudeHold = ship.altHoldPreset1 ship.elevatorActive = true end),\n        SMI(DD([[<span>Preset 2:</span><span class=\"right\">]].. mToKm(ship.altHoldPreset2)..\"</span>\"), function() ship.altitudeHold = ship.altHoldPreset2 ship.elevatorActive = true end),\n        SMI(DD([[<span>Preset 3:</span><span class=\"right\">]].. mToKm(ship.altHoldPreset3)..\"</span>\"), function() ship.altitudeHold = ship.altHoldPreset3 ship.elevatorActive = true end),\n        SMI(DD([[<span>Preset 4:</span><span class=\"right\">]].. mToKm(ship.altHoldPreset4)..\"</span>\"), function() ship.altitudeHold = ship.altHoldPreset4 ship.elevatorActive = true end),\n        SMI(DD([[<span>Altitude:</span><span class=\"right\">{{round2(ship.altitude,4)}}</span>]])).Disable(),\n    }\n\n    self.MenuList.hotkeys = {}\n\n    local fa = \"<style>\" .. CSS_SHUD .. \"</style>\"\n    self.fuel = nil\n    function getFuelRenderedHtml()\n        local fuelHtmlAtmo = \"\"\n        local fuelHtmlSpace = \"\"\n        local fuelHtmlRocket = \"\"\n\n        self.fuel = getFuelSituation()\n        local fuelHtml = \"\"\n\n        local mkTankHtml = (function (type, tank)\n            local tankLevel = 100 * tank.level\n            local tankLiters = tank.level * tank.specs.capacity()\n            return '<div class=\"fuel-meter fuel-type-' .. type .. '\"><hr class=\"fuel-level\" style=\"width:' .. tankLevel .. '%%;\" />' .. tank.time .. ' (' .. math.floor(tankLevel) .. '%%, ' .. math.floor(tankLiters) .. 'L)</div>'\n        end)\n\n        for _, tank in pairs(self.fuel.atmo) do fuelHtml = fuelHtml .. mkTankHtml(\"atmo\", tank) end\n        for _, tank in pairs(self.fuel.space) do fuelHtml = fuelHtml .. mkTankHtml(\"space\", tank) end\n        for _, tank in pairs(self.fuel.rocket) do fuelHtml = fuelHtml .. mkTankHtml(\"rocket\", tank) end\n\n        self.SHUDFuelHtml = fuelHtml\n    end\n\n    opacity = 1.0\n    local template = DD(fa..[[\n    <div id=\"horizon\" style=\"opacity: {{opacity}};\">\n        <svg dd-if=\"enableARReticle\" class=\"shadow\" height=\"100%\" width=\"100%\" viewBox=\"{{SHUD.SvgMinX}} {{SHUD.SvgMinY}} {{SHUD.SvgWidth}} {{SHUD.SvgHeight}}\">\n            <g transform=\"translate({{ship.viewX}},{{ -ship.viewY }}) scale(0.7)\">\n                <line class=\"st0\" x1=\"-0.5\" y1=\"-91.5\" x2=\"-0.5\" y2=\"-11.5\"/>\n                <line class=\"st0\" x1=\"116\" y1=\"-0.5\" x2=\"19\" y2=\"-0.5\"/>\n                <line class=\"st0\" x1=\"-0.5\" y1=\"10.25\" x2=\"-0.5\" y2=\"90.25\"/>\n                <line class=\"st0\" x1=\"-20\" y1=\"-0.5\" x2=\"-117\" y2=\"-0.5\"/>\n                <line class=\"st1\" x1=\"-0.5\" y1=\"-4\" x2=\"-0.5\" y2=\"3\"/>\n                <line class=\"st1\" x1=\"3\" y1=\"-0.5\" x2=\"-4\" y2=\"-0.5\"/>\n                <path class=\"st0\" d=\"M-10,16.34c-5.12-3.4-8.5-9.23-8.5-15.84c0-6.56,3.32-12.34,8.38-15.76\"/>\n                <path class=\"st0\" d=\"M10-15.96c5.68,3.29,9.5,9.43,9.5,16.46c0,7.03-3.82,13.17-9.5,16.46\"/>\n                <g transform=\"rotate({{ shipPitch }} 0,0)\">\n                    <path class=\"st0\" d=\"M-53.99-10.22c3.98-17.83,19.5-38.76,42.99-43.7\"/>\n                    <path class=\"st0\" d=\"M-11,51.99C-32.68,47.76-49.76,30.68-53.99,9\"/>\n                    <path class=\"st0\" d=\"M52.99,9C48.69,31.01,31.15,48.28,9,52.17\"/>\n                    <path class=\"st0\" d=\"M9-54.14c21.87,3.98,39.92,21.42,44.09,43.78\"/>\n                    <line class=\"st0\" x1=\"-53.5\" y1=\"-10.5\" x2=\"-94.5\" y2=\"-10.5\"/>\n                    <line class=\"st0\" x1=\"-54\" y1=\"9.5\" x2=\"-95\" y2=\"9.5\"/>\n                    <polyline class=\"st2\" points=\"53,9.5 84.49,9.5 94,9.5 84.5,13.5 84.5,9.5 \"/>\n                    <polyline class=\"st2\" points=\"53,-10.5 84.49,-10.5 94,-10.5 84.5,-14.5 84.5,-10.5 \"/>\n                </g dd-if=\"ship.world.nearPlanet\">\n            </g>\n        </svg>\n        <div id=\"speedometerBar\">&nbsp;</div>\n           <div id=\"speedometer\">\n               <span class=\"display\">\n               \t<span class=\"major\">{{SpeedConvert(ship.world.velocity:len())[1]}}</span>\n               \t<span class=\"minor\">{{SpeedConvert(ship.world.velocity:len())[2]}}</span>\n               \t<span class=\"unit\">{{SpeedConvert(ship.world.velocity:len())[3]}}</span>\n               </span>\n               <span class=\"accel\">\n               \t<span class=\"major\">{{round2(ship.world.acceleration:len(), 1)}}</span>\n               \t<span class=\"unit\">m/s</span>\n               </span>\n               <span class=\"vertical\">\n               \t{{round2(ship.world.velocity:dot(-ship.world.gravity:normalize()), 1)}}\n               </span>\n               <span class=\"alt\">\n               \t{{round2(ship.altitude)}}m\n               </span>\n\n               <span class=\"misc\">ATM {{round2(ship.world.atmosphericDensity, 2)}} | G {{round2(ship.world.gravity:len(), 2)}}m/s</span>\n               <span dd-if=\"not ship.alternateCM\" class=\"throttle\">Throttle {{round2(ship.throttle * 100)}}%</span>\n\t\t     <span dd-if=\"ship.alternateCM\" class=\"throttle\">Cruise {{round2(ship.cruiseSpeed)}} km/h</span>\n            </div>\n\n            <div id=\"horizon-menu\">\n                {{_SHUDBUFFER}}\n            </div>\n\n            </div>\n            <div id=\"fuelTanks\">{{ SHUD.SHUDFuelHtml }}</div>\n    </div>\n    ]])\n    local itemTemplate = [[<div class=\"item {{class}}\">{{content}}</div>]]\n    function self.SelectMenu(menuName)\n        if not SHUD.MenuList[menuName] then error(\"[SHUD] Undefined menu: \" .. menuName) end\n        SHUD.MenuList.prev = SHUD.Menu\n        SHUD.Menu = SHUD.MenuList[menuName]\n        SHUD.CurrentIndex = 1\n        if SHUD.Menu[#SHUD.Menu] ~= SHUD.BackButton then table.insert(SHUD.Menu, SHUD.BackButton) end\n    end\n\n    function self.Select()\n        if not self.Enabled then return end\n        if #self.Menu < 1 then\n            return\n        end\n        self.Menu[self.CurrentIndex].Action(self.system, self.unit, self.Menu[self.CurrentIndex])\n    end\n\n    function self.Render()\n        local buffer = \"\"\n        if self.Enabled then\n            for i = 1, #self.Menu do\n                local item = self.Menu[i]\n                if item.Active then item.Update(self.system, self.unit, item) end\n                local lb = itemTemplate\n                local cls = \"\"\n                local content = item.Content\n                if content.Read then\n                    content = content.Read()\n                end\n                content = esc(content)\n                if self.CurrentIndex == i then\n                    cls = \"active\"\n                end\n                if not item.Enabled then cls = cls .. \" disabled\" end\n                lb = lb:gsub(\"{{class}}\", cls .. \" \" .. item.Class)\n                lb = lb:gsub(\"{{content}}\", content)\n                buffer = buffer .. lb\n            end\n            _ENV[\"_SHUDBUFFER\"] = esc(buffer)\n        else\n            ship.frozen = player.isFrozen()\n            _ENV[\"_SHUDBUFFER\"] = DD([[<div class=\"item helpText\">Press ]] .. \"[\" .. self.system.getActionKeyName(\"speedup\") .. \"]\" .. [[ to  toggle menu</div>\n                    <div class=\"item helpText\"><span>Character Movement:</span>]].. self.MakeBooleanIndicator(\"ship.frozen\") .. [[</div>\n                    <div class=\"item helpText\"><span>Vertical Lock:</span>]].. self.MakeBooleanIndicator(\"ship.verticalLock\") .. [[</div>\n                    <div class=\"item helpText\"><span>Inertial Dampening:</span>]].. self.MakeBooleanIndicator(\"ship.inertialDampening\") .. [[</div>\n                    <div class=\"item helpText\"><span>Gravity Follow:</span>]].. self.MakeBooleanIndicator(\"ship.followGravity\") .. [[</div>\n                    <div class=\"item helpText\"><span>Gravity Supression:</span>]].. self.MakeBooleanIndicator(\"ship.counterGravity\") .. [[</div>\n                    ]]).Read()\n        end\n        if not self.FreezeUpdate then self.system.setScreen(template.Read()) end\n    end\n\n    function self.Update()\n        if useGEAS then\n            unit.activateGroundEngineAltitudeStabilization(ship.hoverHeight)\n        end\n        if player.isFrozen() or self.Enabled then\n            opacity = 1\n        else\n            opacity = 0.5\n        end\n        if not self.ScrollLock and self.Enabled then\n            local wheel = system.getMouseWheel()\n            if wheel ~= 0 then\n                self.CurrentIndex = self.CurrentIndex - wheel\n                if self.CurrentIndex > #self.Menu then self.CurrentIndex = 1\n                elseif self.CurrentIndex < 1 then self.CurrentIndex = #self.Menu end\n            end\n        elseif not self.Enabled then\n            if player.isFrozen() and unit.isRemoteControlled() then\n                ship.throttle = utils.clamp(ship.throttle + (system.getMouseWheel() * 0.05),-1,1)\n\t\t\tend\n        \tself.UpdateMarkers()\n\t\tend\n\tend\n\n    function self.Init(system, unit, keybinds)\n        self.system = system\n        self.unit = unit\n        self.CurrentIndex = 1\n        self.ScrollLock = false\n        system.showScreen(true)\n        unit.hideWidget()\n        local keys = keybinds.GetNamedKeybinds()\n        self.MenuList.hotkeys = {}\n        for i=1,#keys do\n            local key = keys[i]\n            table.insert(self.MenuList.hotkeys, SMI([[<span>]]..key.Name..[[</span><span class=\"right\">]]..self.system.getActionKeyName(key.Key)..[[</span>]]).Disable())\n        end\n\n        self.MenuList.flightMode = {}\n        for k,v in pairs(keybindPresets) do\n            table.insert(self.MenuList.flightMode,\n            SMI(string.upper(k), function()\n                self.Init(self.system, self.unit, v)\n                keybindPreset = k\n                keybindPresets[keybindPreset].Init()\n            end))\n        end\n\n        keybinds.Init()\n    end\n\n    return self\nend)()",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "16"
    },
    {
      "code": "--@class STEC_Config\n\n\n\nship.hoverHeight = GEAS_Alt\n--charMovement = true\nship.autoShutdown = autoShutdown\nship.altitudeHold = round2(ship.altitude,0)\nship.inertialDampeningDesired = inertialDampening\nship.followGravity = followGravity\nship.minRotationSpeed = minRotationSpeed\nship.maxRotationSpeedz = maxRotationSpeed\nship.rotationStep = rotationStep\n\nship.verticalSpeedLimitAtmo = verticalSpeedLimitAtmo\nship.verticalSpeedLimitSpace = verticalSpeedLimitSpace\nship.approachSpeed = approachSpeed\n\nship.altHoldPreset1 = altHoldPreset1\nship.altHoldPreset2 = altHoldPreset2\nship.altHoldPreset3 = altHoldPreset3\nship.altHoldPreset4 = altHoldPreset4\nship.deviationThreshold = deviationThreshold\nship.pocket = pocket\nship.breadCrumbDist = breadCrumbDist\n\nif construct.setDockingMode(dockingMode) then\n    system.print(\"Docking mode set successfully\")\nelse\n    system.print(\"Invalid docking mode\")\nend\n\nlocal shiftLock = false\n\nif flightModeDb ~= nil then\n    if flightModeDb.hasKey(\"verticalSpeedLimitAtmo\") == 0 or updateSettings then\n        flightModeDb.setFloatValue(\"verticalSpeedLimitAtmo\",verticalSpeedLimitAtmo)\n        ship.verticalSpeedLimitAtmo = verticalSpeedLimitAtmo\n    else ship.verticalSpeedLimitAtmo = flightModeDb.getFloatValue(\"verticalSpeedLimitAtmo\") end\n\n    if flightModeDb.hasKey(\"verticalSpeedLimitSpace\") == 0 or updateSettings then\n        flightModeDb.setFloatValue(\"verticalSpeedLimitSpace\",verticalSpeedLimitSpace)\n        ship.verticalSpeedLimitSpace = verticalSpeedLimitSpace\n    else ship.verticalSpeedLimitSpace = flightModeDb.getFloatValue(\"verticalSpeedLimitSpace\") end\n\n    if flightModeDb.hasKey(\"approachSpeed\") == 0 or updateSettings then\n        flightModeDb.setFloatValue(\"approachSpeed\",approachSpeed)\n        ship.approachSpeed = approachSpeed\n    else ship.approachSpeed = flightModeDb.getFloatValue(\"approachSpeed\") end\n\n    if flightModeDb.hasKey(\"altHoldPreset1\") == 0 or updateSettings then\n        flightModeDb.setFloatValue(\"altHoldPreset1\",altHoldPreset1)\n        ship.altHoldPreset1 = altHoldPreset1\n    else ship.altHoldPreset1 = flightModeDb.getFloatValue(\"altHoldPreset1\") end\n\n    if flightModeDb.hasKey(\"altHoldPreset2\") == 0 or updateSettings then\n        flightModeDb.setFloatValue(\"altHoldPreset2\",altHoldPreset2)\n        ship.altHoldPreset2 = altHoldPreset2\n    else ship.altHoldPreset2 = flightModeDb.getFloatValue(\"altHoldPreset2\") end\n\n    if flightModeDb.hasKey(\"altHoldPreset3\") == 0 or updateSettings then\n        flightModeDb.setFloatValue(\"altHoldPreset3\",altHoldPreset3)\n        ship.altHoldPreset3 = altHoldPreset3\n    else ship.altHoldPreset3 = flightModeDb.getFloatValue(\"altHoldPreset3\") end\n\n    if flightModeDb.hasKey(\"altHoldPreset4\") == 0 or updateSettings then\n        flightModeDb.setFloatValue(\"altHoldPreset4\",altHoldPreset4)\n        ship.altHoldPreset4 = altHoldPreset4\n    else ship.altHoldPreset4 = flightModeDb.getFloatValue(\"altHoldPreset4\") end\n\n    function writeTargetToDb(cVector, name) --customTargetX\n        if flightModeDb ~= nil then\n            flightModeDb.setFloatValue(name..\"X\", cVector.x)\n            flightModeDb.setFloatValue(name..\"Y\", cVector.y)\n            flightModeDb.setFloatValue(name..\"Z\", cVector.z)\n            if settingsActive then settingsActive = false end\n            system.print(\"Target Lock: \"..tostring(cVector))\n        end\n    end\n\n    function readTargetFromDb(name)\n        if flightModeDb ~= nil then\n            local v = vec3(0,0,0)\n            v.x = flightModeDb.getFloatValue(name..\"X\")\n            v.y = flightModeDb.getFloatValue(name..\"Y\")\n            v.z = flightModeDb.getFloatValue(name..\"Z\")\n\n            system.print(\"Target Lock: \"..tostring(v))\n            return v\n        end\n    end\nend\n\nfunction gearToggle()\n\tif unit.isAnyLandingGearExtended() == 1 then\n\t\tunit.retractLandingGears()\n\telse\n\t\tunit.extendLandingGears()\n\tend\nend\nfunction scaleViewBound(rMin,rMax,tMin,tMax,input)\n    return ((input - rMin) / (rMax - rMin)) * (tMax - tMin) + tMin\nend\nfunction switchFlightMode(flightMode)\n    SHUD.Init(system, unit, keybindPresets[flightMode])\n    keybindPreset = flightMode\n    if flightModeDb then flightModeDb.setStringValue(\"flightMode\",flightMode) end\nend\n\nfunction switchControlMode()\n    if ship.alternateCM == false then ship.alternateCM = true\n        else ship.alternateCM = false end\nend\n\nfunction swapForceFields()\n    if manualSwitches ~= nil then\n        if player.isFrozen() then\n            manualSwitches[1].activate()\n            for _, sw in ipairs(forceFields) do\n                sw.retract()\n            end\n        else\n            manualSwitches[1].deactivate()\n            for _, sw in ipairs(forceFields) do\n                sw.deploy()\n            end\n        end\n    end\nend\n\nship.baseAltitude = helios:closestBody(ship.baseLoc):getAltitude(ship.baseLoc)\nsystem.print(\"Altitude: \"..ship.baseAltitude)\n\nif flightModeDb ~= nil then\n    if flightModeDb.hasKey(\"BaseLocX\") == 1 then\n        ship.baseLoc = readTargetFromDb(\"BaseLoc\")\n    else\n        ship.baseLoc = ship.world.position\n        system.print(\"No RTB set\")\n        config.setBaseActive = true\n    end\n    if flightModeDb.hasKey(\"BaseRotX\") == 1 then\n        ship.rot = readTargetFromDb(\"BaseRot\")\n    else\n        ship.rot = ship.world.forward\n        config.setBaseActive = true\n    end\nend\nconfig.rtb = helios:closestBody(ship.baseLoc):getAltitude(ship.baseLoc)\nfunction setBase(a)\n    if a == nil then\n        ship.baseLoc = ship.world.position\n        ship.rot = ship.world.right:cross(ship.nearestPlanet:getGravity(construct.getWorldPosition()))\n        writeTargetToDb(ship.baseLoc,\"BaseLoc\")\n        writeTargetToDb(ship.rot, \"BaseRot\")\n\n        system.print(\"Base Position: \"..tostring(ship.nearestPlanet:convertToMapPosition(ship.baseLoc)))\n    else\n        if string.find(a, \"::pos\") ~= nil then\n            ship.baseLoc = ship.nearestPlanet:convertToWorldCoordinates(a)\n            writeTargetToDb(ship.baseLoc,\"BaseLoc\")\n            writeTargetToDb(ship.rot, \"BaseRot\")\n            system.print(\"Base Position: \"..tostring(ship.nearestPlanet:convertToMapPosition(ship.baseLoc)))\n        end\n    end\n\n    config.rtb = helios:closestBody(ship.baseLoc):getAltitude(ship.baseLoc)\n    ioScheduler.queueData(config)\nend\n\nlocal tty = DUTTY\ntty.onCommand('setbase', function(a)\n    setBase(a)\nend)\n\nkeybindPresets[\"keyboard\"] = KeybindController()\nkeybindPresets[\"keyboard\"].Init = function()\n    keybindPreset = \"keyboard\"\n    --mouse.enabled = false\n    --mouse.unlock()\n    ship.ignoreVerticalThrottle = true\n    ship.throttle = 1\n    --ship.direction.y = 0\nend\n\n\n\n-- keyboard\nkeybindPresets[\"keyboard\"].keyDown.up.Add(function () ship.direction.z = 1 if not ship.counterGravity then ship.counterGravity = true end end)\nkeybindPresets[\"keyboard\"].keyUp.up.Add(function () ship.direction.z = 0 end)\nkeybindPresets[\"keyboard\"].keyDown.down.Add(function () ship.direction.z = -1 end)\nkeybindPresets[\"keyboard\"].keyUp.down.Add(function () ship.direction.z = 0 end)\n\nkeybindPresets[\"keyboard\"].keyDown.yawleft.Add(function () ship.rotation.z = -1 end)\nkeybindPresets[\"keyboard\"].keyUp.yawleft.Add(function () ship.rotation.z = 0 ship.rotationSpeedz = ship.minRotationSpeed end)\nkeybindPresets[\"keyboard\"].keyDown.yawright.Add(function () ship.rotation.z = 1 end)\nkeybindPresets[\"keyboard\"].keyUp.yawright.Add(function () ship.rotation.z = 0 ship.rotationSpeedz = ship.minRotationSpeed end)\n\nkeybindPresets[\"keyboard\"].keyDown.forward.Add(function () ship.direction.y = 1 end)\nkeybindPresets[\"keyboard\"].keyUp.forward.Add(function () ship.direction.y = 0 end)\n\n\nkeybindPresets[\"keyboard\"].keyDown.backward.Add(function () ship.direction.y = -1 end)\nkeybindPresets[\"keyboard\"].keyUp.backward.Add(function () ship.direction.y = 0 end)\n\nkeybindPresets[\"keyboard\"].keyDown.backward.Add(function () ship.direction.y = -1 end)\nkeybindPresets[\"keyboard\"].keyUp.backward.Add(function () ship.direction.y = 0 end)\n\n\nkeybindPresets[\"keyboard\"].keyDown.left.Add(function () ship.direction.x = -1 end) --q\nkeybindPresets[\"keyboard\"].keyUp.left.Add(function () ship.direction.x = 0 end) --q\nkeybindPresets[\"keyboard\"].keyDown.right.Add(function () ship.direction.x = 1 end) --e\nkeybindPresets[\"keyboard\"].keyUp.right.Add(function () ship.direction.x = 0 end) --e\n\nkeybindPresets[\"keyboard\"].keyDown.lshift.Add(function () shiftLock = true end,\"Shift Modifier\")\nkeybindPresets[\"keyboard\"].keyUp.lshift.Add(function () shiftLock = false end)\n\nkeybindPresets[\"keyboard\"].keyDown.brake.Add(function () ship.brake = true end)\nkeybindPresets[\"keyboard\"].keyUp.brake.Add(function () ship.brake = false end)\n\n--keybindPresets[\"keyboard\"].keyDown.stopengines.Add(function () if ship.direction.y == 1 then ship.direction.y = 0 else ship.direction.y = 1 end end, \"Cruise\")\nkeybindPresets[\"keyboard\"].keyUp.stopengines.Add(function () SHUD.Select() if not SHUD.Enabled then if ship.direction.y == 1 then ship.direction.y = 0 else ship.direction.y = 1 end end end, \"Cruise\")\n\nkeybindPresets[\"keyboard\"].keyUp.gear.Add(function () useGEAS = not useGEAS; updateGEAS() end)\nkeybindPresets[\"keyboard\"].keyUp.speedup.Add(function () SHUD.Enabled = not SHUD.Enabled end)\nkeybindPresets[\"keyboard\"].keyUp[\"option1\"].Add(function () ship.inertialDampeningDesired = not ship.inertialDampeningDesired end, \"Inertial Dampening\")\nkeybindPresets[\"keyboard\"].keyUp[\"option2\"].Add(function () player.freeze(not player.isFrozen()); swapForceFields() end,\"Freeze character\")\nkeybindPresets[\"keyboard\"].keyUp[\"option3\"].Add(function () ship.followGravity = not ship.followGravity end, \"Gravity Follow\")\nkeybindPresets[\"keyboard\"].keyUp[\"option4\"].Add(function () ship.counterGravity = not ship.counterGravity end, \"Counter Gravity\")\nkeybindPresets[\"keyboard\"].keyUp[\"option5\"].Add(function ()\n    ship.verticalLock = true\n    ship.lockVector = vec3(construct.getWorldOrientationUp())\n    ship.lockPos = vec3(construct.getWorldPosition()) + (vec3(construct.getWorldOrientationUp()))\n    if flightModeDb ~= nil then\n        flightModeDb.setFloatValue(\"lockVectorX\",ship.lockVector.x)\n        flightModeDb.setFloatValue(\"lockVectorY\",ship.lockVector.y)\n        flightModeDb.setFloatValue(\"lockVectorZ\",ship.lockVector.z)\n        flightModeDb.setFloatValue(\"lockPosX\",ship.lockPos.x)\n        flightModeDb.setFloatValue(\"lockPosY\",ship.lockPos.y)\n        flightModeDb.setFloatValue(\"lockPosZ\",ship.lockPos.z)\n    end\nend,\"Set Vertical Lock\")\nkeybindPresets[\"keyboard\"].keyUp[\"option6\"].Add(function () ship.verticalLock = not ship.verticalLock end,\"Toggle Vertical Lock\")\n--keybindPresets[\"keyboard\"].keyUp[\"option7\"].Add(function () ship.verticalCruise = not ship.verticalCruise end, \"Vertical Cruise\")\nkeybindPresets[\"keyboard\"].keyUp[\"option7\"].Add(function()\n    ship.altitudeHold = ship.baseAltitude ship.elevatorActive = true\n    ship.targetDestination = moveWaypointZ(ship.baseLoc, 0)\nend, \"RTB\")\nkeybindPresets[\"keyboard\"].keyUp[\"option8\"].Add(function () construct.setDockingMode(0); construct.undock() end,\"Undock\")\n--keybindPresets[\"keyboard\"].keyUp[\"option8\"].Add(function () emitter.send(\"door_control\",\"open\") end, \"Open Door\")\n--keybindPresets[\"keyboard\"].keyUp[\"option9\"].Add(function () if ship.targetDestination == nil then ship.targetDestination = moveWaypointZ(ship.baseLoc, 10000 - baseAltitude) else ship.targetDestination = nil end end, \"Preset 2\")\n--keybindPresets[\"keyboard\"].keyUp.option9.Add(function () if flightModeDb ~= nil then flightModeDb.clear() system.print(\"DB Cleared\") end end,\"Clear Databank\")\nkeybindPresets[\"keyboard\"].keyUp[\"option9\"].Add(function ()\n    if shiftLock then\n        flightModeDb.clear() system.print(\"DB Cleared\");\n    else\n        ship.verticalLock = false\n        ship.intertialDampening = true\n        ship.elevatorActive = false\n        config.manualControl = not config.manualControl\n        manualControlSwitch()\n    end\nend,\"Manual Mode Toggle\")\n\nkeybindPresets[\"screenui\"] = KeybindController()\nkeybindPresets[\"screenui\"].Init = function()\n    keybindPreset = \"screenui\"\n    ship.ignoreVerticalThrottle = true\n    ship.throttle = 1\n    player.freeze(true)\n    ship.frozen = false\nend\nkeybindPresets[\"screenui\"].keyDown.lshift.Add(function () shiftLock = true end,\"Shift Modifier\")\nkeybindPresets[\"screenui\"].keyUp.lshift.Add(function () shiftLock = false end)\nkeybindPresets[\"screenui\"].keyDown.brake.Add(function () ship.brake = true end)\nkeybindPresets[\"screenui\"].keyUp.brake.Add(function () ship.brake = false end)\nkeybindPresets[\"screenui\"].keyUp[\"option7\"].Add(function()\n    ship.altitudeHold = ship.baseAltitude ship.elevatorActive = true\n    ship.targetDestination = moveWaypointZ(ship.baseLoc, 0)\nend, \"RTB\")\nkeybindPresets[\"screenui\"].keyUp[\"option8\"].Add(function () construct.setDockingMode(0); construct.undock() end,\"Undock\")\nkeybindPresets[\"screenui\"].keyUp[\"option9\"].Add(function ()\n    if shiftLock then\n        flightModeDb.clear() system.print(\"DB Cleared\");\n    else\n        ship.verticalLock = false\n        ship.intertialDampening = true\n        ship.elevatorActive = false\n        config.manualControl = not config.manualControl\n        manualControlSwitch()\n    end\n    end,\"Manual Mode Toggle\")\nif flightModeDb then\n   if flightModeDb.hasKey(\"flightMode\") == 0 then flightModeDb.setStringValue(\"flightMode\",\"keyboard\") end\n   keybindPreset = flightModeDb.getStringValue(\"flightMode\")\nelse\n   system.print(\"No databank installed.\")\n   keybindPreset = \"keyboard\"\nend\nkeybindPreset = \"keyboard\"\n\nSHUD.Init(system, unit, keybindPresets[keybindPreset])\n\nTask(function()\n    coroutine.yield()\n    SHUD.FreezeUpdate = true\n    local endTime = system.getArkTime() + 2\n    while system.getArkTime() < endTime do\n        coroutine.yield()\n    end\n    SHUD.FreezeUpdate = false\n    SHUD.IntroPassed = true\nend)\n\n\nplayer.freeze(true)\nship.frozen = false\n--ship.throttle = 0\nfunction updateGEAS()\n    if useGEAS then\n        unit.activateGroundEngineAltitudeStabilization(ship.hoverHeight)\n    else\n        unit.deactivateGroundEngineAltitudeStabilization()\n    end\nend\n\nupdateGEAS()\n\ncontrolStateChange = true\n\nfunction normalizeTravelMode()\n\tif ship.controlMode == 1 and controlStateChange then\n\t\tship.cruiseSpeed = round(ship.world.velocity:len() * 3.6,-1)\n\t\tship.throttle = 0\n\t\tcontrolStateChange = false\n\tend\n\tif ship.controlMode == 0 then\n\t\tcontrolStateChange = true\n\tend\nend\n\nfunction autoLandingGear()\n\tif ship.world.velocity:len() >= 83.3333 then\n\t\tunit.retractLandingGears()\n\telse\n\t\tunit.extendLandingGears()\n\tend\nend\n\nconfig.floors.floor1 = ship.altHoldPreset1\nconfig.floors.floor2 = ship.altHoldPreset2\nconfig.floors.floor3 = ship.altHoldPreset3\nconfig.floors.floor4 = ship.altHoldPreset4\nelevatorName = construct.getName()\nconfig.rtb = helios:closestBody(ship.baseLoc):getAltitude(ship.baseLoc)\nconfig.targetAlt = 0\n\nsystem.print(\"Preset 1: \"..config.floors.floor1)\nsystem.print(\"Preset 2: \"..config.floors.floor2)\nsystem.print(\"Preset 3: \"..config.floors.floor3)\nsystem.print(\"Preset 4: \"..config.floors.floor4)\n\nioScheduler.defaultData = stats\nioScheduler.queueData(config)\nioScheduler.queueData(fuelAtmo)\nioScheduler.queueData(fuelSpace)\n",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "17"
    },
    {
      "code": "--@class ElevatorScreen\nElevatorScreen = (function ()\n        local self = {}\n\n        function self.updateStats()\n            stats.data.elevation = ship.altitude\n            stats.data.target = config.targetAlt\n            stats.data.velocity = ship.world.velocity:len()\n            stats.data.mass = ship.mass\n            stats.data.gravity = ship.world.gravity:len()\n            stats.data.target_dist = math.abs(ship.altitude - ship.altitudeHold)\n            stats.data.brake_dist = ship.brakeDistance\n            stats.data.deviation = ship.deviation\n            stats.data.deviationVec = ship.worldToLocal(ship.deviationVec)\n            stats.data.deviationRot = ship.worldToLocal(ship.deviationRot)\n            stats.data.state = ship.stateMessage\n        end\n        self.updateStats()\n        function self.updateScreenFuel()\n            fuelAtmo.tanks = {}\n            fuelSpace.tanks = {}\n\n            for _, tank in pairs(SHUD.fuel.atmo) do\n                table.insert(fuelAtmo.tanks,fuelTank(tank.time,math.ceil(100 * tank.level)))\n            end\n            for _, tank in pairs(SHUD.fuel.space) do\n                table.insert(fuelSpace.tanks,fuelTank(tank.time,math.ceil(100 * tank.level)))\n            end\n            --for _, tank in pairs(SHUD.fuel.rocket) do fuelHtmlRocket = fuelHtmlRocket .. mkTankHtml(\"rocket\", tank) end\n            ioScheduler.queueData(fuelAtmo)\n            ioScheduler.queueData(fuelSpace)\n        end\n        if screen then screen.clearScriptOutput() end\n    return self\nend)()",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "18"
    },
    {
      "code": "--@require SimpleSlotDetectorMin\n--@require ExportedVariables\n--@require PlanetRef\n--@require KinematicsMin\n--@require Serializer\n--@require EventDelegateMin\n--@require TaskManagerMin\n--@require DynamicDocumentMin\n--@require DUTTYMin\n--@require CSS_SHUD\n--@require FuelTankHelper\n--@require TagManagerMin\n--@require KeybindControllerMin\n--@require IOScheduler\n--@require STEC\n--@require AR_HUDMin\n--@require SHUD\n--@require STEC_Config\n--@require ElevatorScreen\n--@timer SHUDRender\n--@timer FuelStatus\n--@timer DockingTrigger\n--@timer Debug\n--@class Main\n\n_G.BuildUnit = {}\nlocal Unit = _G.BuildUnit\n_G.BuildSystem = {}\nlocal System = _G.BuildSystem\n_G.BuildScreen = {}\nlocal buildScreen = _G.BuildScreen\nlocal elevatorScreen = nil\n\nfunction Unit.onStart()\n\t--Events.Flush.Add(mouse.apply)\n\tEvents.Flush.Add(ship.apply)\n\tEvents.Update.Add(SHUD.Update)\n\tgetFuelRenderedHtml()\n\tsystem.print(\"Screen: \"..tostring(screen))\n\tif screen ~= nil then\n\t\tmanualControlSwitch()\n\t\tsystem.print(\"Altitude: \"..helios:closestBody(construct.getWorldPosition()):getAltitude(construct.getWorldPosition()))\n\t\tship.altitudeHold = helios:closestBody(ship.baseLoc):getAltitude(construct.getWorldPosition())\n\t\tship.baseAltitude = helios:closestBody(ship.baseLoc):getAltitude(ship.baseLoc)\n\t\t--ship.elevatorActive = true\n\tend\n\t--if next(manualSwitches) ~= nil then manualSwitches[1].activate() end\n\tif screen == nil then\n\t\tship.verticalLock = false\n\t\tship.intertialDampening = true\n\t\tship.elevatorActive = false\n\t\tconfig.manualControl = not config.manualControl\n\t\tmanualControlSwitch()\n\telse\n\t\televatorScreen = ElevatorScreen\n\tend\n\tif system.showHelper then system.showHelper(false) end\n\tsystem.print(\"ElevatorScreen: \"..tostring(elevatorScreen))\n\tlocal sName = \"\"\n\tlocal coreMass = construct.getTotalMass()\n\tif emitter ~= nil then\n\t\tsystem.print(\"Emitter Range: \"..emitter.getRange())\n\tend\n\tif activateFFonStart then\n\t\tif next(manualSwitches) ~= nil then\n\t\t\tfor _, sw in ipairs(manualSwitches) do\n\t\t\t\tsw.activate()\n\t\t\tend\n\t\tend\n\tend\n\n\tshipName = construct.getName()\n\tsystem.print(player.getId())\n\tunit.setTimer(\"SHUDRender\", 0.02)\n\tunit.setTimer(\"FuelStatus\", 3)\n\tunit.setTimer(\"DockingTrigger\", 1)\n\t--unit.setTimer(\"Debug\", 1)\n\tif laser ~= nil then laser.deactivate() end\n\n\tsystem.print([[Horizon 1.0.1.15]])\n\tif showDockingWidget then\n\t\tparentingPanelId = system.createWidgetPanel(\"Docking\")\n\t\tparentingWidgetId = system.createWidget(parentingPanelId,\"parenting\")\n\t\tsystem.addDataToWidget(unit.getWidgetDataId(),parentingWidgetId)\n\tend\n\n\tif setBaseOnStart then setBase() end\n\t--StepOne.Start()\n\t--ioScheduler.queueData(config)\nend\n\nfunction Unit.onStop()\n\tif next(manualSwitches) ~= nil then\n\t\tfor _, sw in ipairs(manualSwitches) do\n\t\t\tsw.deactivate()\n\t\tend\n\tend\n\tconfig.shutDown = true\n\tif screen then screen.setScriptInput(serialize(config)) end\n\tsystem.showScreen(false)\n\tif laser ~= nil then laser.deactivate() end\n\n\tfor _, sw in ipairs(forceFields) do\n\t\tsw.retract()\n\tend\nend\n\nfunction manualControlSwitch()\n\tif not config.manualControl then\n\t\tSHUD.Init(system, unit, keybindPresets[\"screenui\"])\n\t\tsystem.showScreen(false)\n\t\tplayer.freeze(false)\n\t\tship.frozen = true\n\t\tship.stateMessage = \"Idle\"\n\telse\n\t\tSHUD.Init(system, unit, keybindPresets[\"keyboard\"])\n\t\tsystem.showScreen(true)\n\t\tplayer.freeze(true)\n\t\tship.frozen = false\n\t\tship.stateMessage = \"Manual Control\"\n\tend\n\nend\nlocal emitterOn = false\nlocal tmpClamp = ship.dockingClamps\n\nfunction Unit.onTimer(timer)\n\tif timer == \"SHUDRender\" then\n\t\tif screen == nil then\n\t\t\tif SHUD then SHUD.Render() end\n\t\telseif config.manualControl then\n\t\t\tif SHUD then SHUD.Render() end\n\t\t\tif enableARReticle then updateAR() end\n\t\telse\n\n\t\tend\n\tend\n\tif timer == \"FuelStatus\" then\n\t\tgetFuelRenderedHtml()\n\t\tif elevatorScreen then elevatorScreen.updateScreenFuel() end\n\t\t--ioScheduler.queueData(config)\n\n\tend\n\tif timer == \"DockingTrigger\" then\n\t\tif telemeter ~= nil then telDistance = telemeter.raycast().distance end\n\t\tif ship.dockingClamps then\n\t\t\tif laser ~= nil then laser.activate() end\n\t\t\tif telemeter ~= nil and telDistance > 0 and telDistance < 1 then\n\t\t\t\tif ship.autoShutdown and not config.manualControl then system.print(ship.altitude) unit.exit() end\n\t\t\tend\n\t\tend\n\tend\n\n\tif timer == \"Debug\" then\n\t\tsystem.print(\"[--------------------------------]\")\n\t\tsystem.print(\"ship.altitude: \" .. ship.altitude)\n\t\tsystem.print(\"ship.nearestPlanet: \" .. tostring(ship.nearestPlanet.name[1]))\n\t\t--local waypointString = ship.nearestPlanet:convertToMapPosition(ship.elevatorDestination)\n\t\t--system.print(\"ship.elevatorDestination: \"..tostring((ship.elevatorDestination)))\n\t\t--system.print(waypointString)\n\n\t\tsystem.print(\"[--------------------------------]\")\n\tend\nend\n\nfunction System.onActionStart(action)\n\tkeybindPresets[keybindPreset].Call(action, \"down\")\nend\n\nfunction System.onActionStop(action)\n\tkeybindPresets[keybindPreset].Call(action, \"up\")\nend\n\nfunction System.onInputText(action)\n\tif DUTTY then DUTTY.input(action) end\nend\n\nfunction System.onActionLoop(action)\nend\n\nfunction System.onUpdate()\n\t--system.print(\"Cust Target: \"..tostring(vec3(ship.baseLoc))..\" | alt: \"..ship.altitude..\" | baseAlt: \"..ship.baseAltitude..\" | worldPos: \"..tostring(vec3(ship.world.position))..\" | \")\n\t--self.deviationVec = (moveWaypointZ(self.baseLoc, self.altitude - self.baseAltitude) - self.world.position)\n\tioScheduler.update()\n\tif elevatorScreen then elevatorScreen.updateStats() end\n\tif Events then Events.Update() end\n\tTaskManager.Update()\nend\n\nfunction System.onFlush()\n\tif Events then Events.Flush() end\nend\n\nfunction buildScreen.mouseDown(x,y,slot)\n\t--system.print(\"Mouse X: \"..x..\", Mouse Y: \"..y)\nend\n\nfunction toggleVerticalLock()\n\t--ship.verticalLock = true\n    ship.lockVector = vec3(construct.getWorldOrientationUp())\n    ship.lockPos = vec3(construct.getWorldPosition()) + (vec3(construct.getWorldOrientationUp()))\nend\n\nfunction createBreadcrumbTrail(endAlt)\n\t--Create a set of waypoints starting from the current position to the destination spaced 1km apart\n\tlocal startPosition = moveWaypointZ(ship.baseLoc, ship.world.atlasAltitude - ship.baseAltitude)\n\tlocal endPosition = moveWaypointZ(ship.baseLoc, endAlt)\n\tlocal distance = (startPosition - endAlt):len()\n\tif distance > 1000 then\n\t\tfor i = 1, round2(distance / 1000,0), 1 do\n\t\t\tif ship.nearestPlanet:getAltitude(startPosition) < ship.nearestPlanet:getAltitude(endPosition) then\n\t\t\t\ttable.insert(ship.breadCrumbs, moveWaypointZ(startPosition, 1000 * i))\n\t\t\telse\n\t\t\t\ttable.insert(ship.breadCrumbs, moveWaypointZ(startPosition, -1000 * i))\n\t\t\tend\n\t\tend\n\tend\nend\n--local btrail = createBreadcrumbTrail(3)\n--system.print(\"Breadcrumbs:\")\n--for _, sw in ipairs(ship.breadCrumbs) do\n--\tsystem.print(\"POS: \"..tostring(sw))\n--end\nfunction buildScreen.mouseUp(x,y,slot)\n--ship.baseAltitude = helios:closestBody(ship.baseLoc):getAltitude(ship.baseLoc)\n--\tif settingsActive then\n--\t\tif mousex >= 0.1515 and mousex <= 0.4934 and mousey >= 0.5504 and mousey <= 0.7107 then --Setbase button\n--\t\t\tsetBase()\n--\t\t\tsettingsActive = false\n--\t\tend\n--\t\tif mousex >= 0.5097 and mousex <= 0.8511 and mousey >= 0.5504 and mousey <= 0.7134 then --Cancel button\n--\t\t\tsettingsActive = false\n--\t\tend\n--\t\tif mousex >= 0.0277 and mousex <= 0.0868 and mousey >= 0.8515 and mousey <= 0.9484 then --Settings button\n--\t\t\tsettingsActive = false\n--\t\tend\n\n--\t\tif mousex >= 0.0277 and mousex <= 0.0868 and mousey >= 0.8515 and mousey <= 0.9484 then --Settings button\n--\t\t\tsettingsActive = true\n--\t\tend\n--\tend\nend",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "19"
    },
    {
      "code": "_G.BuildUnit.onStart()",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-1"
      },
      "key": "20"
    },
    {
      "code": "_G.BuildUnit.onStop()",
      "filter": {
        "args": [],
        "signature": "onStop",
        "slotKey": "-1"
      },
      "key": "21"
    },
    {
      "code": "_G.BuildSystem.onActionStart(action)",
      "filter": {
        "args": [
          {
            "variable": "*"
          }
        ],
        "signature": "onActionStart(action)",
        "slotKey": "-2"
      },
      "key": "22"
    },
    {
      "code": "_G.BuildSystem.onActionStop(action)",
      "filter": {
        "args": [
          {
            "variable": "*"
          }
        ],
        "signature": "onActionStop(action)",
        "slotKey": "-2"
      },
      "key": "23"
    },
    {
      "code": "_G.BuildSystem.onInputText(action)",
      "filter": {
        "args": [
          {
            "variable": "*"
          }
        ],
        "signature": "onInputText(action)",
        "slotKey": "-2"
      },
      "key": "24"
    },
    {
      "code": "_G.BuildSystem.onUpdate()",
      "filter": {
        "args": [],
        "signature": "onUpdate",
        "slotKey": "-2"
      },
      "key": "25"
    },
    {
      "code": "_G.BuildSystem.onFlush()",
      "filter": {
        "args": [],
        "signature": "onFlush",
        "slotKey": "-2"
      },
      "key": "26"
    },
    {
      "code": "_G.BuildUnit.onTimer(\"SHUDRender\")",
      "filter": {
        "args": [
          {
            "variable": "SHUDRender"
          }
        ],
        "signature": "onTimer(timerId)",
        "slotKey": "-1"
      },
      "key": "27"
    },
    {
      "code": "_G.BuildUnit.onTimer(\"FuelStatus\")",
      "filter": {
        "args": [
          {
            "variable": "FuelStatus"
          }
        ],
        "signature": "onTimer(timerId)",
        "slotKey": "-1"
      },
      "key": "28"
    },
    {
      "code": "_G.BuildUnit.onTimer(\"DockingTrigger\")",
      "filter": {
        "args": [
          {
            "variable": "DockingTrigger"
          }
        ],
        "signature": "onTimer(timerId)",
        "slotKey": "-1"
      },
      "key": "29"
    },
    {
      "code": "_G.BuildUnit.onTimer(\"Debug\")",
      "filter": {
        "args": [
          {
            "variable": "Debug"
          }
        ],
        "signature": "onTimer(timerId)",
        "slotKey": "-1"
      },
      "key": "30"
    },
    {
      "code": "_G.BuildReceiver.onReceived(channel, message, slot1)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onReceived(channel,message)",
        "slotKey": "0"
      },
      "key": "31"
    },
    {
      "code": "_G.BuildScreen.onMouseDown(x, y, slot1)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseDown(x,y)",
        "slotKey": "0"
      },
      "key": "32"
    },
    {
      "code": "_G.BuildScreen.onMouseUp(x, y, slot1)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseUp(x,y)",
        "slotKey": "0"
      },
      "key": "33"
    },
    {
      "code": "_G.BuildReceiver.onReceived(channel, message, slot2)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onReceived(channel,message)",
        "slotKey": "1"
      },
      "key": "34"
    },
    {
      "code": "_G.BuildScreen.onMouseDown(x, y, slot2)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseDown(x,y)",
        "slotKey": "1"
      },
      "key": "35"
    },
    {
      "code": "_G.BuildScreen.onMouseUp(x, y, slot2)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseUp(x,y)",
        "slotKey": "1"
      },
      "key": "36"
    },
    {
      "code": "_G.BuildReceiver.onReceived(channel, message, slot3)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onReceived(channel,message)",
        "slotKey": "2"
      },
      "key": "37"
    },
    {
      "code": "_G.BuildScreen.onMouseDown(x, y, slot3)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseDown(x,y)",
        "slotKey": "2"
      },
      "key": "38"
    },
    {
      "code": "_G.BuildScreen.onMouseUp(x, y, slot3)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseUp(x,y)",
        "slotKey": "2"
      },
      "key": "39"
    },
    {
      "code": "_G.BuildReceiver.onReceived(channel, message, slot4)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onReceived(channel,message)",
        "slotKey": "3"
      },
      "key": "40"
    },
    {
      "code": "_G.BuildScreen.onMouseDown(x, y, slot4)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseDown(x,y)",
        "slotKey": "3"
      },
      "key": "41"
    },
    {
      "code": "_G.BuildScreen.onMouseUp(x, y, slot4)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseUp(x,y)",
        "slotKey": "3"
      },
      "key": "42"
    },
    {
      "code": "_G.BuildReceiver.onReceived(channel, message, slot5)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onReceived(channel,message)",
        "slotKey": "4"
      },
      "key": "43"
    },
    {
      "code": "_G.BuildScreen.onMouseDown(x, y, slot5)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseDown(x,y)",
        "slotKey": "4"
      },
      "key": "44"
    },
    {
      "code": "_G.BuildScreen.onMouseUp(x, y, slot5)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseUp(x,y)",
        "slotKey": "4"
      },
      "key": "45"
    },
    {
      "code": "_G.BuildReceiver.onReceived(channel, message, slot6)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onReceived(channel,message)",
        "slotKey": "5"
      },
      "key": "46"
    },
    {
      "code": "_G.BuildScreen.onMouseDown(x, y, slot6)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseDown(x,y)",
        "slotKey": "5"
      },
      "key": "47"
    },
    {
      "code": "_G.BuildScreen.onMouseUp(x, y, slot6)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseUp(x,y)",
        "slotKey": "5"
      },
      "key": "48"
    },
    {
      "code": "_G.BuildReceiver.onReceived(channel, message, slot7)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onReceived(channel,message)",
        "slotKey": "6"
      },
      "key": "49"
    },
    {
      "code": "_G.BuildScreen.onMouseDown(x, y, slot7)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseDown(x,y)",
        "slotKey": "6"
      },
      "key": "50"
    },
    {
      "code": "_G.BuildScreen.onMouseUp(x, y, slot7)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseUp(x,y)",
        "slotKey": "6"
      },
      "key": "51"
    },
    {
      "code": "_G.BuildReceiver.onReceived(channel, message, slot8)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onReceived(channel,message)",
        "slotKey": "7"
      },
      "key": "52"
    },
    {
      "code": "_G.BuildScreen.onMouseDown(x, y, slot8)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseDown(x,y)",
        "slotKey": "7"
      },
      "key": "53"
    },
    {
      "code": "_G.BuildScreen.onMouseUp(x, y, slot8)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseUp(x,y)",
        "slotKey": "7"
      },
      "key": "54"
    },
    {
      "code": "_G.BuildReceiver.onReceived(channel, message, slot9)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onReceived(channel,message)",
        "slotKey": "8"
      },
      "key": "55"
    },
    {
      "code": "_G.BuildScreen.onMouseDown(x, y, slot9)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseDown(x,y)",
        "slotKey": "8"
      },
      "key": "56"
    },
    {
      "code": "_G.BuildScreen.onMouseUp(x, y, slot9)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseUp(x,y)",
        "slotKey": "8"
      },
      "key": "57"
    },
    {
      "code": "_G.BuildReceiver.onReceived(channel, message, slot10)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onReceived(channel,message)",
        "slotKey": "9"
      },
      "key": "58"
    },
    {
      "code": "_G.BuildScreen.onMouseDown(x, y, slot10)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseDown(x,y)",
        "slotKey": "9"
      },
      "key": "59"
    },
    {
      "code": "_G.BuildScreen.onMouseUp(x, y, slot10)",
      "filter": {
        "args": [
          {
            "variable": "*"
          },
          {
            "variable": "*"
          }
        ],
        "signature": "onMouseUp(x,y)",
        "slotKey": "9"
      },
      "key": "60"
    },
    {
      "code": "_G._ModuleIndex={}\r\n_G._ModuleIndex[0]='SimpleSlotDetectorMin.lua';_G._ModuleIndex[1]='ExportedVariables.lua';_G._ModuleIndex[2]='PlanetRef.lua';_G._ModuleIndex[3]='KinematicsMin.lua';_G._ModuleIndex[4]='Serializer.lua';_G._ModuleIndex[5]='EventDelegateMin.lua';_G._ModuleIndex[6]='TaskManagerMin.lua';_G._ModuleIndex[7]='DynamicDocumentMin.lua';_G._ModuleIndex[8]='DUTTYmin.lua';_G._ModuleIndex[9]='shud2.lua';_G._ModuleIndex[10]='FuelTankHelper.lua';_G._ModuleIndex[11]='TagManagerMin.lua';_G._ModuleIndex[12]='KeybindControllerMin.lua';_G._ModuleIndex[13]='IOScheduler.lua';_G._ModuleIndex[14]='STEC.lua';_G._ModuleIndex[15]='AR_HUDMin.lua';_G._ModuleIndex[16]='SHUD.lua';_G._ModuleIndex[17]='STEC_config.lua';_G._ModuleIndex[18]='ElevatorScreen.lua';_G._ModuleIndex[19]='main.lua';",
      "filter": {
        "args": [],
        "signature": "onStart",
        "slotKey": "-3"
      },
      "key": "1"
    }
  ],
  "methods": [],
  "events": []
}